[{"title":"Barnery--无限列表的实现IntersectionObserver","date":"2020-05-07T01:38:21.062Z","path":"2020/05/07/Barnery--无限列表的实现IntersectionObserver/","text":"在前端开发中，无限列表是一个常见的实现场景。在展示商品的时候，因为需要去做一些打点和曝光之类的统计，需要知道每个商品是否有出现列表可视化区域。如果用常规的js去做，会用到大量的计算，但是如果用IntersectionObserver去做的话，只需要给每个item注册下，并提供一个满足触发条件时，需要执行的回调函数就可以了。 具体使用方法： 创建一个 IntersectionObserver对象。 12345const io = new IntersectionObserver(callback, &#123; root: document.querySelector('#rootElement'), rootMargin: '1000px', threshold: 0.75&#125;) root是根元素，如果目标元素与根元素相交，就会触发回调 rootMargin可以将根元素的作用扩大或缩小，采用的是元素margin的用法 threshold是当目标元素与根元素相交多少比例的时候，触发回调函数。可以是一个0-1之间的数字，也可以是一个由一个数组。如果是数组，比如[0, 0.25, 0.5, 0.75, 1]那么就在目标元素与根元素刚相交，相交比例在0.25、0.5、0.75、1时，分别调用一次回调函数。 监听目标函数 12// 监听目标元素io.observe(document.querySelector('#targetElement')); 监听目标函数的时候会执行一次无条件执行一次callback，如果是一组目标函数，则会放在一起执行。entries的数组存放的是同一事件循环中所有执行被监听的目标元素。 此外，io还有一些其他的API 1234// 取消监听目标元素io.unobserve(document.querySelector('#targetElement'));// 关闭监听器io.disconnect(); 触发回调，给回调函数传参数 123456789101112131415// 回调函数接收两个参数// entries是所有被监听的目标元素组成的数组// observe是1.中创建的IntersectionObserver对象iofunction callback (entries, observer) &#123; console.log(entries.length); entries.forEach(entry =&gt; &#123; console.log('无条件触发'); if (entry.intersectionRatio &gt;= 0.75) &#123; console.log('满足条件触发') observer.unobserve(entry.target); &#125; &#125;)&#125; entries中属性及其含义 在3.中，我们从entry中拿到了一个intersectionRatio的值。表示的是触发时，目标元素与根元素的相交的比例。其实，entry对象中还有其他的信息，具体可以参考MDN：https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry中的讲述。 具体实例：https://gist.github.com/baiai/9c27f983a74772197b39eeedab44aacc","tags":[]},{"title":"Barnery--数据请求加锁","date":"2020-05-07T01:38:11.355Z","path":"2020/05/07/Barnery--数据请求加锁/","text":"在前端向后端发送服务请求的时候，可能由于网络环境较差，用户会反复点击发送服务请求的按钮，这样就会导致短时间内前端会向后端发送同样的服务请求。所以，一般我们需要给向后端发送服务请求的方法加一个锁，使得在本次请求结束之前，前端不会向后端发送同样的服务请求。 具体的实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637// 锁function requestPendingWrapper (fn) &#123; let promise = null; let loading = false; // 加锁的标志 return async (...params) =&gt; &#123; console.log('run'); if (loading) return promise; loading = true; // 加锁 try &#123; const promise = fn(...params); return await promise; &#125; catch (err) &#123; throw err; &#125; finally &#123; loading = false; // 解锁 promise = null; &#125; &#125;;&#125;// 模拟数据请求const requestMock = async (param) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(param), 5000); &#125;);&#125;;const wrappedRequest = requestPendingWrapper(async (str) =&gt; &#123; const name = await requestMock(str); console.log(name);&#125;);setInterval(() =&gt; wrappedRequest('name'), 1000); 运行结果是： 加锁是通过闭包的方式，让作为返回值的函数可以读取loading和promise的值。所以当loading === false的时候，会直接返回当前的promise。而当当前的promise完成之后，一定会去执行finally中的代码，这时候会讲loading只为false，表示解锁，可以再次发起新的数据请求了。 这种方法其实和节流函数是一样的原理，都是在一段时间内只做一次。但是为什么不直接用节流函数呢？因为一般在开发过程中，数据请求除了可以发送请求和处理返回结果之外，还有其他的一些通用的逻辑，比如，当后端还未返回数据的时候，会有一个菊花图之类的方法。类似这样的方法，也可以在requestPendingWrapper中封装起来较少代码的重复率，提高代码的复用率。","tags":[]},{"title":"BWT比对算法","date":"2020-04-24T16:00:00.000Z","path":"2020/04/25/Billy-- BWT比对算法/","text":"目前二代测序常用的比对软件BWA和Bowtie核心算法都是BWT(Burrows-Wheeler Transform)算法。事实上,BWT是一种数据转换算法,它将一个字符串中的相似字符放在相邻的位置,以便于后续的压缩。 BWT算法可以分为编码和解码两部分。编码后,原始字符串中的相似字符会处在比较相邻的位置;解码就是将编码后的字符串重新恢复成原始字符串的过程。BWT的一个特点就是经过编码后的字符串可以完全恢复成原始字符串。 &lt;1&gt; BWT算法编码部分本文以GACCTA序列作为参考,进行算法推导。推导的过程如图1所示。 (1) 加标记 在GACCTA序列的右侧加上一个比序列中所有字符的ASCII码都小的标记符号,例如$。 (2) 推导循环矩阵 将标记后字符串的最后一个字符提到最前,组成新的字符串。接着在该字符串基础上,又将最后一个字符提到最前,再次组成一个新的字符串。依次循环,直到标记符号再次回到最后一位。 这些字符串则形成一个所谓的循环矩阵(如图1的循环矩阵列)。 (3) 对循环矩阵排序 根据ASCII码从小到大的顺序,对循环矩阵进行排序(如图1的矩阵排序列)。 (4) 得到循环矩阵的F列和L列 提取排序后的矩阵的第一列字符,作为F列。 提取排序后的矩阵的最后一列字符,作为L列。 图1 BWT算法编码部分推导过程 &lt;2&gt; BWT算法解码部分我们以上一步骤得到的F列和L列,回推出GACCTA序列,回推过程如图2所示。 需要注意的是,回推过程是从序列最后一位向第一位进行的,也就是第一个回推出来的字符是A,第二个是T,第三个是C,…,最后一个是G。 (1) 解码起点(回推倒数第一个字符) (A) 如图2(子图1)所示,我们以L列的标记符号$作为解码的起点。 (B) 在F列找到同样的字符$。 (C) 与F列字符$同一行的L列字符就是解码序列的最后一个字符。这里得到的字符是A。 (2) 回推倒数第二个字符 (A) 以上一步骤L列的A字符作为开始。 (B) 同样的,在F列的寻找相同字符A。然而,可以看到F列并不止存在一个A字符,解决的方案是:A字符在L列是排第几个,就对应F列的第几个。比如这里,A是L列两个A字符的第一个,则对应的也是F列的第一个A字符。 (C) 与F列字符A同一行的L列字符就是解码序列的倒数第二个字符。这里得到的字符是T。 (3) 回推倒数第三个字符 (A) 以上一步骤L列的T字符作为开始。 (B) 同样的,在F列的寻找相同字符T。 (C) 与F列字符T同一行的L列字符就是解码序列的倒数第三个字符。这里得到的字符是C。 (4) 回推的终点 如上述步骤,依次回推,直到最后在L列得到的字符是$标记符时,回推结束。 从图2可以看到,最后得到的序列GACCTA是正确的。 图2 BWT算法解码部分推导过程 &lt;3&gt; 序列比对案例假设上面所用的序列GACCTA是参考序列,我们模拟将CAA比对到这个参考序列上的过程。 与解码过程一样,比对也是从后向前进行,因此第一个比对的字符是A。 然而,可以在L列上发现有两个A字符,分别以两个字符进行比对。如图3所示,分别比对到CAG和CCA两个位置。然后根据自行定义的打分系统,排除错误的CAG,保留正确的CCA。 图3 序列比对推导过程","tags":[{"name":"算法","slug":"算法","permalink":"https://liangbilin.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"编码红线","date":"2020-04-20T03:42:00.000Z","path":"2020/04/20/Barnery--编码红线/","text":"最近在看《A Philosophy of Software Design》，总结和记录一下读后感。顺便长期维护一下这个文章，将自己在编码过程中常出现的一些错误总结起来。 本书主要是在讲解一些开发中不好的coding习惯或者方法，以及如何去避免和解决这些问题。书中主要提及了两个概念：dependency 和 obscurity。dependency回导致change amplification和cognitive load。而obscurity会导致cognitive load和unknown unknowns。所以开发中都是在避免这两个特性出现，而他们的具体表现则是下面列举的一些场景。 Tactical Programing 在开发过程中，很多时候我们会急于去完成需求，从而忽略了如何写出更好的设计的代码，但是如果是一个长期需求维护的需求，越到后面，前期因为tactiacl programming带来的副作用就会越来越明显，甚至到最后不得不重写或者花很大的力气重构代码。 过度封装（shallow module） 封装的原则是高内聚、低耦合。对外的接口要尽可能的少，同时不要对一些简单功能去封装一层函数或者类，这样会导致在看代码的时候返回查看封装的代码，看代码的流畅感会被阻断。但是对一些复用性很高的方法和类的封装还是很有必要的。 不写注释或者注释复述代码 不写注释的都是坏蛋。注释是去阐述一段代码是做什么的，而不是怎么做的。所以，注释不要去解释代码是怎么执行的，读代码的人会自己去看代码是如何运行的。注释只需要给需要用到这段代码讲清楚这段代码是干嘛的就好了。 代码不动，注释先行。先写注释，可以整理开发思路，给后续写代码提供一个整体的思路。而且在开始的时候就把重要的方法和变量的命名给定下来。 命名模糊 命名要满足这些： 能够让自己和其他人对这个命名能够清晰的概念在。知道这个变量或者方法是干什么的。 命名不要含糊不清，要表达的精确。如何你不知道如何去命名，那么可能你还没有弄清楚这个变量或者方法需要完成的是什么。这个时候，你可能需要去将这个模糊的概念再去细分，直到能够细分出来的东西都有一个精确的命名。 同时，命名要坚持从一而终。不要一会用这样的名字，一会儿用一个名字。比如标签，不要一会儿起tag，一会又叫label，这样会很混乱。或着弹窗的展示都叫popupVisible，就不要再用什么shouldShowPopup。要有统一的命名规范。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"利用CIPRES云计算构建最大似然进化树","date":"2020-04-19T16:00:00.000Z","path":"2020/04/20/Billy--利用CIPRES云计算构建最大似然进化树/","text":"&lt;1&gt; 利用 makeblastdb 构建本地blast数据库参照利用NCBI的Blast+进行本地化序列相似性检索。 &lt;2&gt; 利用 blastall 在本地数据库中进行blast除了使用blastall软件之外,也可以使用blast+,参照利用NCBI的Blast+进行本地化序列相似性检索。 1blastall -p blastn -d /path/to/database/blast.db -i query.fasta -o output.txt -e 1e-10 -m 8 -b 250 -a 20 blastall程序的常用参数说明: -d 设置通过makeblastdb构建的本地数据库-i 输入序列文件,FASTA格式-o 程序输出结果文件-b 程序计算保留前多少条序列,如本次为250,则表示结果保留最相似的250条序列-e 期望值,这一参数控制搜索的灵敏度,可以输入整数(如100),分数 (如1/100),小数 (如0.001)或是指数 (如5e-5),默认值是10.0。-m 设定搜索结果的显示格式,m参数的选项有12个-a 程序运行调用的核数目 -m 参数备选值以及对应意义 -m 0 默认参数,显示query和subject两两比对的信息-m 1 显示query在所有subjects上的定位信息,并显示一致性比对信息,subject之间不同的碱基/氨基酸会被标出-m 2 显示query在所有subjects上的定位信息但是不显示一致性比对信息,subject之间不同的碱基/氨基酸会被标出-m 3 显示query在所有subjects的定位和一致性比对信息,不显示subjects之间的差异-m 4 显示query在所有subjects上的定位信息但是不显示一致性比对信息,不显示subjects之间的差异-m 5 显示query在所有subjects上的定位信息但是不显示每个碱基/氨基酸的比对信息,补充“-”比对区域,subjects之间不同的碱基/氨基酸会被标出-m 6 显示query在所有subjects上的定位信息但是不显示每个碱基/氨基酸的比对信息,补充“-”对齐比对区域,不显示subjects之间的差异-m 7 输出XML格式的blast结果-m 8 用列表格式显示比对结果。从左到右各列的意义依次是:query名, subject名,一致性百分数,比对长度,错配数,空位数,query比对起始位 点和终止位点,subject比对起始位点和终止位点,期望值,比对得分-m 9 用带有注释行的列表格式显示比对结果,格式与-m 8一样,只是在每 个query的必读结果前面加了注释行用于说明列表中各列的意义-m 10 输出文件为ASN格式的文本文件-m 11 输出文件为二进制文件 &lt;3&gt; 提取blast结果序列blastall程序在选择-m 8或-m 9参数后的结果文件中,含有blast得到的序列ID信息。这一步骤就是根据这个序列ID,提取序列并保存为FASTA格式。 提取的程序脚本和方法参照Extract sequences from fasta file by name。 &lt;4&gt; 多序列比对以提取出来的序列作为输入文件,利用Cluster Omega软件进行多序列比对。EBI网页平台提供了在线Cluster Omega计算服务;也可以在本地服务器中安装Cluster Omega软件。 &lt;5&gt; 手动修剪比对后的序列文件在BioEdit程序中打开比对后序列文件,如下图。 为了减少计算误差,需要删除序列两端参差不齐的部分序列。这一过程比较主观,其中一种方法是删除起始密码子(ATG)之前的序列,以及终止密码子之后的序列。 &lt;6&gt; 构建最大似然进化树前的准备(A) 在构建进化树之前,需要通过JmodelTest软件计算适合该数据的最优模型。 (B) 本次使用的构建程序为 CRISPR 云计算平台,该工具对序列ID中的特殊符号敏感,即ID中不能含有逗号、空格、分号等符号。因此需要使用Notebook ++等工具替换掉。 &lt;7&gt; 使用CIPRES云计算平台构建最大似然进化树(A) 使用个人邮箱注册CIPRES云计算平台; (B) 在云平台创建任务,并将准备好的序列文件上传至云平台。 (C) 选择计算程序和设置程序参数。这里,我们选择RaxML-HPC2 on XSEDE作为程序。并在参数设置中,计算模型选择JmodelTest计算出来的最优模型;Bootstrap iteration参数设置为1000。 (D)待计算完成后,下载进化树文件。为了适用进化树可视化软件Figtree,需要对文件做格式转换。即在Notebook++等支持正则表达式的软件中,:([\\.\\d]+)\\[(\\d+)\\]替换为$2:$1。","tags":[{"name":"进化树","slug":"进化树","permalink":"https://liangbilin.github.io/tags/%E8%BF%9B%E5%8C%96%E6%A0%91/"}]},{"title":"Python语法","date":"2020-03-05T16:00:00.000Z","path":"2020/03/06/Billy--Python复合语法/","text":"Python语法常见的一些语法。 &lt;1&gt; 基于列表构造字典 先创建两个列表,其中一个作为字典的键,另一个作为字典的值。 123456country = ['China', 'India', 'Japan']population = [14, 16, 1]dic_ = &#123;country[i]: population[i] for i in range(len(country))&#125;print(dic_)# &#123;'China': 14, 'India': 16, 'Japan': 1&#125; 在上面的基础上天剑if判断控制。 1234dic_1 = &#123;country[i]: population[i] for i in range(len(country)) if i == 1&#125;print(dic_1)# &#123;'India': 16&#125; &lt;2&gt; Python语言没有一元增量(x++)或递减(x–)12345x = 1x += 1 ## x = x + 1x += 3 ## x = x + 3x *= 2 ## x = x * 2x -= 4 ## x = x - 4 &lt;3&gt; 遍历列表元素123animals = ['cat', 'dog', 'monkey']for animal in animals: print(animal) 使用enumerate函数遍历一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列,同时列出数据和数据下标,一般用在 for 循环当中。 enumerate函数语法,如下: 1enumerate(sequence, [start=0]) sequence – 一个序列、迭代器或其他支持迭代对象。start – 下标起始位置。 1234seasons = ['Spring', 'Summer', 'Fall', 'Winter']for idx_, val_ in enumerate(seasons): print(idx_, val_) print(\"---\") 0 Spring-–1 Summer-–2 Fall-–3 Winter-– 参考信息https://www.numpy.org.cn/article/basics/python_numpy_tutorial.html#%E5%AE%B9%E5%99%A8-containers","tags":[{"name":"Python","slug":"Python","permalink":"https://liangbilin.github.io/tags/Python/"}]},{"title":"利用NCBI的Blast+进行本地化序列相似性检索","date":"2020-02-26T16:00:00.000Z","path":"2020/02/27/Billy--利用NCBI的Blast+进行本地化序列相似性检索/","text":"(一) 软件安装 推荐使用bioconda安装 1conda install -c bioconda blast=2.9.0 在NCBI官方网站选择最新版本,进行下载安装。 (二) 创建本地数据库1makeblastdb -in demo_db.fasta -dbtype nucl -out dbname 参数说明: -in 输入待建库的序列数据,如demo.fasta-input_type 输入待建库的序列数据格式,可选asn1_bin, asn1_txt, blastdb, fasta,默认为fasta。-dbtype 序列数据类型,即核酸还是氨基酸。可选为nucl(核酸),prot(氨基酸)-out 生成的数据名称其他参数,可以使用makeblastdb -help查看。 (三) 选择检索程序根据不同的需求,比如所使用的序列是氨基酸还是核酸,要查找的数据是核酸还是氨基酸,选择合适的blast工具。不同的工具使用方法大致相同,在本篇 Demo 中,仅选择更常用的blastn和blastp工具进行介绍。 Query Sequence Type Databse Sequence Type Alignment level Type Program nucleotide nucleotide nucleotide blastn peptide peptide peptide blastp nucleotide peptide peptide blastx peptide nucleotide peptide tblastn nucleotide nucleotide peptide tblastx (四) 序列相似性搜索12345# 核酸序列检索blastn -query demo_query.fa -out demo.blast -db dbname -outfmt 6 -evalue 1e-5 -num_descriptions 10 -num_threads 8# 氨基酸检索blastp -query demo_query.fa -out demo.blast -db dbname -outfmt 6 -evalue 1e-5 -num_descriptions 10 -num_threads 8 参数说明: -query 输入待搜索的序列-out 输出结果的文件名-db 上一步骤建立的本地数据库名,也可以是NCBI的在线数据库。-outfmt 输出结果文件的格式,总共有18种。一般选择6,即Tab分隔的文本文件。-evalue 设置输出结果的evalue值-num_descriptions Tab格式输出的条数-num_threads 程序线程数-remote: 可以用NCBI的远程数据库, 一般与 -db nr 输出文件格式: 0 = pairwise1 = query-anchored showing identities2 = query-anchored no identities3 = flat query-anchored, show identities4 = flat query-anchored, no identities5 = XML Blast output6 = tabular7 = tabular with comment lines8 = Text ASN.19 = Binary ASN.110 = Comma-separated values11 = BLAST archive (ASN.1)12 = Seqalign (JSON)13 = Multiple-file BLAST JSON14 = Multiple-file BLAST XML215 = Single-file BLAST JSON16 = Single-file BLAST XML217 = Sequence Alignment/Map (SAM)18 = Organism Report (五) 输出结果以输出格式 6 的输出结果,是一个Tab分隔的文档文件,一般情况,我们选择提取序列的名称,然后使用脚本从构建数据库的FASTA序列文件中提取序列。 序列提取参考作者之前编写的脚本。 (六) 其他特殊应用:基因注释对已有序列进行注释时常见的best hit only模式命令行: 1blastn -query gene.fa -out gene.blast.txt -task megablast -db nt -num_threads 12 -evalue 1e-10 -best_hit_score_edge 0.05 -best_hit_overhang 0.25 -outfmt \"7 std stitle\" -perc_identity 50 -max_target_seqs 1 参数详解: -task megablast : 任务执行模式,可选有’blastn’ ‘blastn-short’ ‘dc-megablast’ ‘megablast’ ‘rmblastn’-best_hit_score_edge 0.05 : Best Hit 算法的边界值,取值范围为0到0.5,系统推荐0.1-best_hit_overhang 0.25 : Best Hit 算法的阈值,取值范围为0到0.5,系统推荐0.1-perc_identity 50 : 相似度大于50-max_target_seqs 1 : 最多保留多少个联配 (七) 使用blastall进行相似性搜索除了直接使用blastn、blastn等程序之外,还可以使用blastall来调用程序。 blastall软件程序的参数如下: -p: 执行的程序名称-d: 搜索的数据库名称-i : 要查询的序列文件名(Query File)-e:(数学)期望值(Expectation value),E值是个统计阈值,缺省值10, 意指比对结果中由于随机偶然性产生的匹配结果不大于10,E值越小结果越可靠。-o :查询结果输出文件名-m: 比对结果显示格式选项,缺省值为0 ,即pairwise格式。另外还可以根据不同的需要选择1~6等不同的格式。-I :在描述行中显示gi号[T/F],缺省值F-v :单行描述(one-line description)的最大数目,缺省值500-b :显示的比对结果的最大数目,缺省值250-F :对于要查询的序列做低复杂度区域(low complexity regions, LCR)的过滤[T/F],缺省值T。对blastn用的是DUST程序,其他比对用的是SEG程序。所谓“低复杂度区域”是指某些或一些残基过多表现,短周期重复等。对于高等哺乳动物的基因组序列,可以先用RepeatMask程序遮蔽重复元件。在输出结果中,对LCR区的序列核酸用“N”代替,蛋白质序列用“X”代替。-a:运行BLAST程序所使用的处理器的数目,缺省值1-S:在数据库中搜索时所使用的核酸链(strand),只对blastn、blastx和tblastx有效;1表示top,2表示bottom,3表示both;缺省值3-T: 产生HTML格式的输出[T/F],缺省值F-n: 使用MegaBlast搜索[T/F],缺省值F-G: 打开一个gap的罚分(0表示使用缺省设置值),默认0-E: 扩展一个gap的罚分(0表示使用缺省设置值),默认0-q: 一个核酸碱基的错配(mismatch)的罚分(只对blastn有效),缺省值-3-r : 一个核酸碱基的正确匹配(match)的奖分(只对blastn有效),缺省值1-M: 所使用的打分矩阵,缺省值BLOSUM62","tags":[{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"JS面向对象程序设计","date":"2020-02-24T03:09:00.000Z","path":"2020/02/24/Barney--JS面向对象程序设计/","text":"理解对象对象中有四个属性描述符分别是： [[Configurable]]：表示是否能通过delete删除该属性或者能否修改属性的特性。默认是true 12345678910111213141516171819202122const person = &#123; name: 'barney', age: 25&#125;;Object.defineProperty(person, 'name', &#123; value: 'barney', writable: true, configurable: false, enumerable: true&#125;);delete person.name;delete person.age;console.log(person.name, person.age); // barney undefinedObject.defineProperty(person, 'name', &#123; value: 'billyy', writable: true, configurable: true, enumerable: true&#125;); // 这句话会报错，因为一旦[[configurable]]的值为false之后，就不能再转换为true了，是一个不可逆过程 可以看到，当属性描述符[[configurable]]为false之后，无法通过delete删除该属性了。 [[Enumberable]]：表示能否通过for...in循环返回属性。默认是true 123456789101112131415161718192021function logProprties (obj) &#123; for (const i in obj) &#123; console.log(i); &#125;&#125;const person = &#123; name: 'barney', age: 25&#125;;logProprties(person); // name ageObject.defineProperty(person, 'name', &#123; value: 'barney', writable: true, configurable: true, enumerable: false&#125;);logProprties(person); // age 可以看到，当name的[[Enumberable]]为true的时候，通过for...in是可以访问到name属性的，但是改为false之后，就无法通过for...in访问到了。 [[Writable]]：是否可以修改数据的值。默认是true 1234567891011121314151617const person = &#123; name: 'barney', age: 25&#125;;Object.defineProperty(person, 'name', &#123; writable: false&#125;);person.name = 'billy';console.log(person.name); // barneyObject.defineProperty(person, 'name', &#123; value: 'billy'&#125;);console.log(person.name); // billy 可以看到，当[[Writable]]为false的时候，name的值已经不能直接通过赋值语句来修改了。只能通过Object.defineProperty来修改了。 [[Value]]：当前属性的值，默认是undefiend 访问器属性： [[get]]：在读取的时候调用的函数，默认值是undefined [[set]]：在写入属性值 的时候调用的函数，默认值是undefined 12345678910111213141516171819const person = &#123; _name: 'barney', age: 25&#125;;Object.defineProperty(person, 'name', &#123; get: function getName () &#123; return `my name is $&#123;this._name&#125;`; &#125;, set: function setName (val) &#123; this._name = val; console.log('set name success'); &#125;&#125;);console.log(person.name); // my name is barneyperson.name = 'billy'; // set name successconsole.log(person.name); // my name is billy 定义多个属性的特性可以用Object.defineProperties()，而获取一个对象的属性特性可以用Object.getOwnPropertyDescriptor()。 创建自定义对象一个对象其实就是数据和操作数据方法的集合。下面将介绍很多中创建对象的方法，是一个循序渐进的优化路径，最终只有一两个是常用的，但是这个优化思路需要逐步递进。 工厂模式 123456789101112function createPerson (name, age, job) &#123; const obj = new Object(); obj.name = name; obj.age = age; obj.job = job; obj.sayName = function () &#123; console.log(this.name); &#125; return obj;&#125;const person = createPerson('barney', 25, 'engineer'); 工厂模式解决了创建多个相似对象的问题，但是每个对象与创建他们函数无法有太多联系，即无法知道person与createPerson之间的关系。 构造函数模式：明确对象与构造函数之间的关系 12345678910function Person (name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function () &#123; console.log(this.name); &#125;;&#125;const person = new Person('barney', 25, 'engineer');person.sayName(); // barneyconsole.log(person instanceof Person); // true 可以通过instanceof来判断对象person是构造函数Person的实例。但是可以看到每个实例都自己实现了一次sayName方法，但是他们的行为是一样，所以我们应该只实现一次sayName方法。 1234567891011function sayName () &#123; console.log(this.name); &#125;function Person (name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;const person = new Person('barney', 25, 'engineer');person.sayName(); // barney 可以看到，我们在Person外部定义一个sayName方法，这样就可以只实现一次sayName方法了。但是这样做的话，就将sayName与Person解耦了。但其实sayName是Person特有的方法，其他的对象是不能调用的。 构造函数+原型链模式：解决共享函数的问题。（重要） 123456789101112// 构造函数function Person (name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype.sayName = function () &#123; console.log(this.name); &#125;;const person = new Person('barney', 25, 'engineer');person.sayName(); // barneyconsole.log(person instanceof Person); // true 可以看到，数据等每个实例特有的属性，都放在构造函数Person中，而对这些数据的共同操作则放在Person.prototype上，这样相同的行为逻辑就只实现了一次，而且还是在Person的原型链上。这样，其他的类型的对象就没有办法直接调用sayName这个方法了。而这种模式也是比较常用的模式。 继承继承是面向对象的一个非常重要且常用的手段，JS中的继承方法主要有两个。 组合继承 1234567891011121314151617181920212223242526272829function User (name) &#123; this.name = name;&#125;User.prototype.sayName = function () &#123; console.log(this.name); &#125;;function Vip (name, level) &#123; User.call(this, name); this.level = level;&#125;// 将prototype指向User的实例，User的实例的[[prototype]]指向User.prototype，这样Vip.prototype就可以访问User.prototype上的方法了。Vip.prototype = new User();// 上一句修改了Vip.prototype.constructor的指向，指向了Object.prototype，所以现在要重新指向默认的VipVip.prototype.construtor = Vip;// 定义新的方法只能通过Vip.prototype.xxx的格式，不能用字面量表示法Vip.prototype.sayLevel = function () &#123; console.log(this.level); &#125;;const user = new User('Billy');user.sayName();console.log(user instanceof User);const vip = new Vip('Barney', 2);vip.sayName();vip.sayLevel();console.log(vip instanceof Vip);console.log(vip instanceof User); 组合继承中可以看到，User构造函数被调用了两次，其中一次是为了让Vip.prototype与User.prototype之间产生链接，我们将这一步优化一下，创建一个指向User.prototype的对象就可以了。这样User就只需要调用一次，而且可读性也更强。 123456789101112131415161718192021222324252627function User (name) &#123; this.name = name;&#125;User.prototype.sayName = function () &#123; console.log(this.name); &#125;;function Vip (name, level) &#123; User.call(this, name); this.level = level;&#125;const proto = User.prototype;proto.constructor = Vip;Vip.prototype = proto;Vip.prototype.sayLevel = function () &#123; console.log(this.level); &#125;;const user = new User('Billy');user.sayName(); // Billyconsole.log(user instanceof User); // trueconst vip = new Vip('Barney', 2);vip.sayName(); // Barneyvip.sayLevel(); // 2console.log(vip instanceof Vip); // trueconsole.log(vip instanceof User); // true ClassJS中的Class是更接近面向对象的表达方式，但是Class的实质仍然是Function，所以，可以把Class看作是Function的一种语法糖。具体类如何实现上面的User和Vip，看示例 12345678910111213141516171819202122232425class User &#123; constructor (name) &#123; this.name = name; &#125; sayName () &#123; console.log(this.name); &#125;&#125;class Vip extends User &#123; constructor (name, level) &#123; super(name); this.level = 2; &#125; sayLevel () &#123; console.log(this.level); &#125;&#125;const vip = new Vip('Barney', 2);vip.sayName();vip.sayLevel(); 这样写，可读性更好。需要注意的是，子类中的constructor调用super方法。而关于更多class的细节问题参考: https://es6.ruanyifeng.com/#docs/class和https://es6.ruanyifeng.com/#docs/class-extends","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"JS的引用类型","date":"2020-02-23T07:02:00.000Z","path":"2020/02/23/Barnery--引用类型/","text":"在ECMAScript中，引用类型是一种数据结构，而这种数据结构的实例称之为对象。创建一个对象的方式主要有两种：构造函数和字面量表示法。 12345678910// 构造函数const person = new Object();person.name = 'barney';person.age = 25;// 字面量表示法const person = &#123; name: 'barney', age: 25&#125;; 而获取属性的值的方法也有两种，分别是：’.’和’[]’。一般情况都是使用’.’访问，但是如果访问的属性名需要使用计算或者拼接或者是变量时，使用’[]’。 12const keys = ['name', 'age'];person[keys[0]]; // 'barney' 此外，引用类型还定义了其他许多常用的数据结构：Array、Date、RegExp、Function。 Array12345678910111213141516171819const colors = ['red', 'green', 'blue'];// 数组检测方法Array.isArray(colors); // trueObject.prototype.toString.call(colors); // [object Array]// 数组字符串拼接方法：colors.join('_'); // red_green_yellow// 栈方法colors.push('yellow'); // ['red', 'green', 'blue', 'yellow']colors.pop(); // ['red', 'green', 'blue']// 队列方法colors.shift(); // [green', 'blue']colors.unshift('red'); // ['red', 'green', 'blue']// 重排序方法colors.reverse(); // [ 'blue', 'green', 'red' ]，排序反了[12, 1, 7, 5].sort(); // [ 1, 12, 5, 7 ] 此处sort之所以没有按照预期那样排序是因为，默认情况下，sort放法会将数组中的值转换为字符串之后在比较。所以就产生了12 &lt; 5这样的情况。如果想要符合预期的话，需要传入一个比较函数。如下： 12345const increaseCompare = (pre, cur) =&gt; pre - cur; // 从小到大排序const decreaseCompare = (pre, cur) =&gt; cur - pre; // 从大到小排序[12, 1, 7, 5].sort(increaseCompare); // [ 1, 5, 7, 12 ][12, 1, 7, 5].sort(decreaseCompare); // [ 12, 7, 5, 1 ] 以上的方法都是会改变原数组的。 12345678910111213141516171819202122232425262728293031323334353637383940414243const Log = console.log;const numbers = [1, 2, 3, 4, 5, 6];// 操作方法// slice 不改变原有数组const sliceNumbers = numbers.slice(0, 2);Log(numbers, sliceNumbers); // [1,2,3,4,5,6] [1,2]// concat 不改变原有数组const concatNumbers = numbers.concat([7, 8]);Log(numbers, concatNumbers); // [1,2,3,4,5,6] [1,2,3,4,5,6,7,8]// splice 改变原数组const spliceNumbers = numbers.splice(1, 2, 7, 8);Log(numbers, spliceNumbers); // [1,7,8,4,5,6] [2,3]// 位置方法，比较时使用的是 === 操作符const idx = numbers.indexOf(2);const lastIdx = numbers.lastIndexOf(2);const testIdx = numbers.indexOf(100);const testLastIdx = numbers.lastIndexOf(100);Log(idx, lastIdx, testIdx, testLastIdx); // 1 1 -1 -1// 迭代方法 不改变原有的数组// every，运行给定的函数，如果给定函数对每一项都返回true，则返回trueconst everyNumbersResult = numbers.every(item =&gt; item &gt; 0);Log(everyNumbersResult); // true// filter，返回运行给定函数结果是true的项组成的数组const filterNumbers = numbers.filter(item =&gt; item &gt; 3);Log(filterNumbers); // [ 4, 5, 6 ]// forEach，没有返回值，每一项都运行一次给定函数const copyNumbers = [];numbers.forEach(item =&gt; copyNumbers.push(item));// map，返回运行给定函数返回的结果的数组const mapNumbers = numbers.map(item =&gt; item * 2);Log(mapNumbers); // [ 2, 4, 6, 8, 10, 12 ]// some，只要有一项运行给定函数返回true，则返回trueconst someNumbersResult = numbers.some(item =&gt; item === 6);Log(someNumbersResult); // true 归并方法。归并方法接受四个参数：前一个值、当前值、项的索引、数组对象。后面两个参数不一定需要显示传入。调用的函数的返回值会作为下一次迭代的前一个值，当前值则是该数组当前索引的值。 1234567891011121314const Log = console.log;const numbers = [1, 2, 3, 4];const sum = numbers.reduce((pre, cur, index, arr) =&gt; &#123; Log(pre, cur, index, arr); return pre + cur;&#125;);Log(sum);// 结果是：// 1 2 1 [ 1, 2, 3, 4 ]// 3 3 1 [ 1, 2, 3, 4 ]// 6 4 1 [ 1, 2, 3, 4 ]// 10 ES6对数组方法的扩充： 123456789101112131415const Log = console.log;const numbers = [1, 2, 3, 4];// includes，返回bool值，判断数组中是否含有某个值numbers.includes(2); // true// fill，将数组填充。第一个参数是填充的值，第二个参数是填充的起始位置，第三个参数是结束位置，会改变原有的数组numbers.fill(0, 1, 3); // [ 1, 0, 0, 4 ]// find，顺序查找第一个满足条件的项并返回项的值，没找到返回undefiendnumbers.find(item =&gt; item &gt; 3); // 4// findIndex，顺序查找第一个满足条件的项并返回项的索引，没找到返回undefinednumbers.find(item =&gt; item &gt; 1); // 2// Array.from()，将类数组转换为数组 RegExp123// 创建一个正则表达式对象let pattern = /ja/gim;let pattern = new RegExp('ja', 'gim'); 正则表达式对象也有五个属性： lastIndex：表示表达式从待检索的字符串那个位置开始检索，一个字符串对象； ignoreCase：boolean值，表示是否忽略大小写； global：boolean值，表示是否全局搜索； multiline：boolean值，表示是否多行搜索； source：RegExp表示的文本 常用的方法exec：返回一个数组arr，arr[0]是匹配的字符，arr[1…n]是第i个子表达式（即括号内的正则表达式）匹配的文本。返回的数组还有两个属性：index匹配字符的起始位置，input表示正在检索的字符串。如果正则表达式有g标志，则下一次查询会从上一次查询到的字符串的下一个位置开始查询。 123456789101112const Log = console.log;const searchName = /barney/ig;const searchIs = /i/gi;const str = 'barney is a software engineer. Now he lives in ShangHai with two roommates';Log(searchName.exec(str)); // [\"barney\", index: 0, input: \"barney is a software engineer. Now he lives in ShangHai with two roommates\", groups: undefined]Log(searchIs.exec(str)); // [\"i\", index: 7, input: \"barney is a software engineer. Now he lives in ShangHai with two roommates\", groups: undefined]Log(searchName.exec(str)); // nullLog(searchIs.exec(str)); // [\"i\", index: 24, input: \"barney is a software engineer. Now he lives in ShangHai with two roommates\", groups: undefined] test()：返回一个boolean，表示待检索字符串是否含有符合RegExp的字符串。 123456789const Log = console.log;const searchBarney = /barney/ig;const searchBilly = /billy/gi;const str = 'barney is a software engineer. Now he lives in ShangHai with two roommates';Log(searchBarney.test(str)); // trueLog(searchBilly.test(str)); // false 与string类型搭配使用 正则表达式还可以用于string类型的变量的模式匹配： str.search(regexp)：返回字符串中第一个匹配正则的位置，没找到返回-1； str.match(regexp)：没有找到返回null，如果找到则返回数组，如果regexp带有全局flag，返回的是匹配正则表达式的所有字符串。如果没有全局flag，返回的是匹配的字符串以及index和input。和exec一样； str.replace(regexp, replacement)：找到匹配regexp的字符串并用replacement替换掉； str.split(regexp, num)：以匹配正则的子字符串分裂字符串，返回一个数组。num是可选，表示的是返回的数组的长度。 书写规则方括号 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。 元字符 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 引用类型还有Date、Function、String、Number、Boolean、Global、Math等等，这些要么简单，要么内容比较多，不适合放在一起。而数组和正则表达式是比较常用且重要的内容，但是相对较难，所以就先写这些了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"肿瘤新生抗原","date":"2020-02-17T16:00:00.000Z","path":"2020/02/18/BIlly--肿瘤新生抗原/","text":"（一） 肿瘤的发生与治疗人类个体漫长的生命过程中,除了遗传携带的DNA突变外,如强紫外线、某些化学试剂、病毒感染等等都有可能造成个体某些细胞的DNA突变。随着生命的旅程,这些DNA突变将逐渐累积,也就有可能演变为肿瘤。 传统的肿瘤治疗方法包括手术治疗、放疗、化疗以及靶向药疗法四类。然而这四种方法均有各自的局限性:手术切除无法解决微小病灶以及转移性病灶的问题,且手术效果取决于患者肿瘤组织形态以及医生经验;放疗、化疗对于身体正常组织器官有较大的毒副作用;靶向药容易产生耐药性等问题。 肿瘤免疫疗法是新一代的抗肿瘤疗法,是指利用机体自身的免疫系统来清楚肿瘤细胞。其基本思路是通过解除肿瘤微环境的免疫抑制、提高树突状细胞的抗原呈递功能及促进产生保护性T细胞等方式激活人体自身的免疫系统,从而达到识别和杀伤癌细胞的目的。 （二） 肿瘤新生抗原是现有免疫疗法中最为有效的biomarker无论是传统疗法还是免疫疗法,基本点仍然是如何区分正常细胞与肿瘤细胞,然后才是去考虑如何清除肿瘤细胞。新生抗原(Neoantigen) 是一类肿瘤特异性抗原,它是由于基因突变、病毒感染、基因重排等原因产生的,并被MHC分子递呈至肿瘤细胞表面,从而激活免疫系统的异常多肽。 新生抗原的产生过程如图1。突变可以通过转录成mRNA并经过核糖体翻译后形成长肽链,进一步被蛋白酶体水解,形成6-30个氨基酸不等的抗原肽,内质网表面的抗原加工相关转运体(TAP)可选择性地将部分抗原肽转移至内质网腔内。抗原肽在内质网中与MHC I类分子形成复合物,pMHC复合物通过小囊泡运送至细胞膜附近,最终通过膜融合的方式锚定于细胞表面,供CD8+ T细胞识别。需要注意的是,MHC I类分子在递呈抗原肽的同时也会递呈体细胞内源性的小肽,因此,尽管肿瘤新生抗原已被证明普遍存在,但有可能在不同的肿瘤细胞表面,被递呈的肿瘤新生抗原数量及种类均有较大的差别。 图1. 肿瘤新生抗原合成路径(来源:CCR Review) 可以看出,肿瘤新生抗原的体内合成是一个多步骤的复杂过程。因此,从肿瘤细胞中的基因突变到肿瘤新生抗原的形成,至少需要考虑突变的基因及突变类型、蛋白酶体降解情况、TAP转运可能性以及抗原肽与MHC亲和力等因素。此外,为了实现免疫逃逸,肿瘤可能会下调抗原递呈相关信号通路的基因表达,比如删除MHC-I中与抗原肽直接互作的HLA分子基因等。因此,上述任意的限制都有可能造成新生抗原肽递呈的失败。2014年《Nature》的一篇文章曾以M38肿瘤细胞系为对象,研究体细胞基因突变与肿瘤新生抗原的数量关系。可以看出,对于外显子组中的28439个突变,可被质谱检测出的肿瘤新生抗原仅有7个,其中被证明有较强免疫原性的新生抗原为3个。即便考虑到质谱的灵敏性限制了新生抗原的检出,真实存在的肿瘤新生抗原数量也十分有限。 图2. 肿瘤体细胞突变箭头→肿瘤新生抗原中的数量变化(来源:Nature) （三） 肿瘤新生抗原的应用前景&lt;1&gt; 免疫疗法体外诊断免疫检查点抑制剂、过继性细胞疗法和肿瘤疫苗是当前临床上已被证明的免疫疗法。在研发和临床应用时,患者首先需要接受伴随诊断(IVD的一种)。这是一个极为重要的环节,它决定了患者更加适合的治疗方案、初步判断所使用的药物不良反应和最大疗效。伴随诊断的需求在肿瘤治疗的靶向药阶段就已经逐渐出现,但靶向药由于其作用机制较为明确,伴随诊断仅需对某一个/几个特定的基因类型进行检测,较为便捷因而相对成熟。肿瘤免疫疗法的伴随诊断涉及到免疫过程的多个阶段,其中的机制复杂交错,大多数情况下在科研上仍没有被充分解释,这对伴随诊断的准确性带来了极大的挑战。从概念上来说,肿瘤免疫治疗的核心在于帮助免疫系统更好地识别肿瘤这一异于自体正常情况的组织,解除肿瘤微环境的免疫抑制、加强肿瘤杀伤能力。因此,新生抗原作为肿瘤中最为特异性的存在,是起始肿瘤免疫的瓶颈,也是IVD能够做出更精确评估的核心所在。 以免疫检查点抑制剂疗法(ICIs)为例,其基本假设为:患者首先已经存在抗肿瘤的T细胞反应,PD-1/PD-L1抗体阻断剂疗法才能进一步发挥作用。肿瘤浸润性T细胞首先通过TCR识别肿瘤新生抗原并部分激活,上调PD-1表达并释放IFN-γ, IFN-γ则造成肿瘤细胞免疫相关蛋白如MHC-I类分子表达的上调,加强对于肿瘤新生抗原的递呈,增强免疫原性。同时肿瘤细胞应对IFN-γ亦会上调PD-L1的表达,通过PD-1/PD-L1抑制性信号通路实现免疫赦免。PD-(L)1抗体阻断了抑制性信号,因此浸润性T细胞可以发挥肿瘤杀伤的作用。可以看出,这一治疗机制的第一步在于免疫系统通过肿瘤新生抗原对癌细胞进行识别。 &lt;2&gt; 体外诊断的biomarker目前对于PD-1/PD-L1用药的伴随诊断包括肿瘤PD-L1表达情况、肿瘤突变负荷(TMB)、微卫星不稳定性(MSI)、HLA分型、肿瘤新生抗原负荷(TNB)以及其他科研中明确揭示的生理或病理功能的相关基因。其中,PD-L1的表达通过免疫组化(IHC)实现,其他biomarkers大多数通过基于杂交-捕获的NGS进行分析。在多种biomarkers中,PD-L1表达和MSI/dMMR(基因错配修复功能缺陷)状态已被FDA批准用于PD-(L)1疗法的伴随诊断,其他仍处于研究阶段。 2017年美国FDA批准了PD-1抗体pembrolizumab 用于治疗微卫星不稳定性高/错配修复缺陷(MSI-H/dMMR)的实体瘤患者,是FDA首次批准的不依照肿瘤来源,而是biomarker进行区分的抗肿瘤疗法。对dMMR的检测可通过对特定的DNA错配修复蛋白的IHC实现,MSI-H可通过PCR以及NGS进行检测。由于dMMR会造成MSI-H,因此将二者看作同一个指标。 肿瘤突变负荷(TMB)是近年来biomarker研究的热点,其最直观的定义是肿瘤细胞外显子中每兆碱基对(Mbp)中出现的体细胞突变个数。其作为biomarker的基本假设是肿瘤基因组突变数量越多,形成的突变多肽被呈递至细胞表面成为肿瘤新生抗原的可能性就越大,因而更能从ICIs中获益。然而如之前所述,并不是所有基因的突变都与肿瘤新生抗原直接相关,另外,不同突变类型(SNV、Indels等)所对应的免疫原性也不尽相同。如果不加偏向性地检测尽可能多的基因的突变情况,除了大大增加成本之外,还有可能导致数据质量的退化,使得真正有意义的突变被淹没在众多数据当中,如果检测机构对假阳性数据进行过滤的算法并未得到很好的training,则很容易做出错误的判断。此外,对于TMB-H/M/L的cutoff值设定,在不同机构当中也不尽相同,一些认为TMB ≥25个/Mb为TMB-H;同时有一些机构对于肿瘤新生抗原和基因突变相关性的理解更强,数据检测及分析灵敏度更高,也会将TMB≥15个/Mb甚至更低的值定义为TMB-H。目前对于TMB具体检测基因类型以及cutoff值仍没有统一的定义,但可以推知的是,由于TMB实质上是肿瘤新生抗原的替代标志物,因此对肿瘤新生抗原有更深刻理解的机构才能在进一步控制成本的前提下增加TMB作为biomarker的指导意义。 HLA是一种在科研上得到相对明确验证的biomarker。在HLA-I类分子中,HLA直接参与抗原肽的结合与递呈。因此患者自身HLA的杂合性越高,能够递呈的肿瘤新生抗原种类越多。如果肿瘤细胞通过一系列突变删除了HLA相关基因(loss of heterozygosity, LOH)或者出现了MHC-I组成成分β2微球蛋白的缺陷甚至缺失,能够递呈的抗原肽则大大降低(如图?)。目前限制HLA作为biomarker进行推广应用的原因在于HLA基因是人群中多态性最强的基因(超过10000多种等位基因),如何提高探针捕获不同HLA等位基因的成功率是其中的关键点。 图3. 自身HLA杂合,TMB-H患者更容易从ICI疗法中获益(来源:Science) 图4. 肿瘤HLA-LOH及TMB-L的患者对ICI疗法响应降低(来源:Science) 研究表明,PD-L1表达情况与TMB这两种biomarker之间并没有明显相关性。PD-L1表达水平反映的是T细胞炎症性的肿瘤微环境,而包括TMB、TNB、MSI和HLA在内的多种biomarker,针对的是肿瘤新生抗原形成的可能性。目前越来越多的研究显示,在ICI研发及诊疗的过程中,需要运用多种biomarkers进行综合评估以提高伴随诊断的准确性。其中,对于肿瘤新生抗原的进一步理解将极大地提升ICI以及ICI-combo疗法伴随诊断的准确性 图5. ICIs伴随诊断中的biomarkers及其指征 &lt;3&gt; TCR-T和肿瘤疫苗肿瘤新生抗原可以作为个性化TCR-T及肿瘤疫苗的靶点。例如基于新生抗原,设计并制备个体化抗肿瘤疫苗注射剂,通过皮下注射激活患者体内特异的T细胞,使患者自身免疫系统能够有效识别、杀灭肿瘤细胞,以及预防肿瘤的复发。然而,TCR-T和肿瘤疫苗要求肿瘤新生抗原的精准预测。较强的免疫原性是保证疗效的重要因素,这对肿瘤新生抗原的预测提出了远高于ICI伴随诊断的精度要求。依据现有的研究结果,肿瘤新生抗原作为靶点的能力仍然需进一步提高。对于肿瘤疫苗而言,如何同时选取多新生抗原表位共同使用以增加疫苗的免疫刺激性,疫苗是否能够驱动足够的T细胞发生激活,而激活后的T细胞是否能一定转移至肿瘤并行使杀伤作用,都需要进一步的回答。对于TIR及TCR-T疗法,如何更高效地鉴定新生抗原特异性TCR,是否需要工程化改造TCR进一步增加对肿瘤新生抗原的亲和力,同时平衡好药效及副作用之间的关系,同样需要科研及临床实践的不断累积。理论上来说,对于肿瘤新生抗原,尤其是强免疫原性肿瘤新生抗原的预测,会大大减少下游验证成本,同时增加对应疗法的效果,提高后续药物在早期研发阶段的成功率。","tags":[{"name":"肿瘤","slug":"肿瘤","permalink":"https://liangbilin.github.io/tags/%E8%82%BF%E7%98%A4/"},{"name":"新生抗原","slug":"新生抗原","permalink":"https://liangbilin.github.io/tags/%E6%96%B0%E7%94%9F%E6%8A%97%E5%8E%9F/"}]},{"title":"this","date":"2020-02-11T04:07:00.000Z","path":"2020/02/11/Barney--this/","text":"call-stack &amp; call-site调用栈：函数调用的顺序。 调用点：调用函数时所在的调用栈。 结合下面这个示例，可以更好的理解这两个概念。 12345678910111213141516171819202122function foo1 () &#123; // call-stack: global-&gt;foo1 console.log('foo1'); // call-site: foo2 foo2();&#125;function foo2 () &#123; // call-stack: global-&gt;foo1-&gt;foo2 console.log('foo2'); // call-site: foo3 foo3();&#125;function foo3 () &#123; // call-stack: global-&gt;foo1-&gt;fool2-&gt;fool3 console.log('foo3');&#125;foo1(); // call-stack: global, call-site: foo1 this的指向this的指向是由函数运行是的调用点决定的。并且是遵循下面四个规则： 默认绑定 默认绑定会将this只想全局作用域，如果是在严格模式下，则不会只想全局作用域。同时，默认绑定是四个绑定规则中，优先级最低的。即，如果有其他形式的绑定规则出现，就不会使用默认绑定了。 下面是示例： 12345678// 全局作用域function foo () &#123; console.log(this.a);&#125;var a = 1;foo(); // 1 如果是严格模式： 1234567891011121314// 全局作用域'use strict';function foo () &#123; console.log(this.a);&#125;var a = 1;try &#123; foo();&#125; catch (err) &#123; console.log(err); // TypeError: Cannot read property 'a' of undefined&#125; 隐式绑定 隐式绑定是指一个对象调用它内部的函数时，被调用的函数内部的this指向这个对象。 12345678910function foo () &#123; console.log(this.a);&#125;let obj = &#123; a: 1, foo: foo&#125;obj.foo(); // 隐式绑定，this指向obj，所以打印的是 1 链式隐式绑定时，this指向的是最后一个调用函数的对象。 123456789101112131415function foo () &#123; console.log(this.a);&#125;let obj1 = &#123; a: 1, foo: foo&#125;let obj2 = &#123; a: 2, obj1: obj1&#125;obj2.obj1.foo(); // this指向最后一个调用函数的对象obj1，打印的结果是 1 隐式绑定丢失： 隐式绑定必须用obj.func的形式调用，如果期间发生引用赋值，被赋值的对象会发生隐式绑定丢失，因为被赋值的对象其实只是拿到了函数的引用，最后调用的时候使用的默认绑定的规则。 123456789101112131415let obj = &#123; a: 'obj', foo: function () &#123; console.log(this.a); &#125;&#125;var a = 'global';let bar = obj.foo; // 隐式绑定丢失function baz(fn) &#123; fn(); // 默认绑定&#125;obj.foo(); // 隐式绑定，打印结果：objbar(); // 默认绑定，打印结果：globalbaz(obj.foo); // 隐式绑定丢失，打印结果：global 如果foo是箭头函数咋整？箭头函数没有自己的this指针，而是与外层的this绑定在一起的，所以这个时候就需要确定外层的this的绑定。比如： 12345678910111213141516function foo1 () &#123; console.log(this.a);&#125;const foo2 = () =&gt; &#123; console.log(this.a); // this指向foo2所在的作用域，没有a的变量声明，打印结果是undefined&#125;;const obj = &#123; a: 1, foo1, foo2&#125;;obj.foo1(); // 隐式绑定，this指向obj，所以打印的是 1obj.foo2(); // undefined 更多细节在：YDKJSY 3-2， P26 显示绑定 显示绑定是通过apply、call、bind来实现的，可以指定this需要指向的对象。 12345678910111213function foo () &#123; console.log(this.a);&#125;const obj1 = &#123; a: 1&#125;const obj2 = &#123; a: 2&#125;foo.call(obj1); // 1，将foo中的this指向obj1foo.apply(obj2); // 2，将foo中的this指向obj2 显然每次使用foo的时候都需要调用一次，如果this指向的对象是可变的，倒也还好。如果this指向的是固定不变的，这个时候apply和call就不方便了。所以，这个时候需要用bind。 123456789101112131415function foo () &#123; console.log(this.a);&#125;const obj1 = &#123; a: 1&#125;const obj2 = &#123; a: 2&#125;const bar = foo.bind(obj1);bar(); // 1，这个时候不会发生类似隐式绑定的this丢失，this始终指向objbar.call(obj2); // 2，即使再用apply、bind也不会改变this的指向了 具体可以看一下bind是如何用aplly、call实现的。 new 绑定 new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空对象 将这个的对象的__ proto __指向构造函数的prototype 将构造函数的this指向新对象 如果构造函数有返回值，就返回值，没有这个新对象。 12345678910111213function foo (a) &#123; this.a = a;&#125;foo.prototype.name = 'foo';foo.prototype.sayName = function () &#123; console.log(this.name);&#125;;const bar = new foo(2); // bar.__proto__ = foo.prototypeconsole.log(bar.a); // 2console.log(bar.name); // foobar.sayName(); // foo 绑定的优先级new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 如果显示绑定使用的传入的this指向是null或者undefined的话，就会退化成默认绑定。 123456function foo () &#123; console.log(this.a);&#125;const a = 2;foo.call(null); // 默认绑定，相当于foo()，打印结果是：2 apply实现bind1234567891011121314151617181920212223242526272829if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what ' + 'is trying to be bound is not callable' ); &#125; var aArgs = Array.prototype.slice.call(arguments, 1); var fToBind = this; var fNOP = function () &#123;&#125;; var fBound = function () &#123; return fToBind.apply( ( this instanceof fNOP &amp;&amp; oThis ? this : oThis ), aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125; ; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 由此可见，bind是返回了一个始终func.apply(args)的函数，所以每次调用的时候，才不用再次显示调用apply了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"CSS优化","date":"2020-02-10T02:09:00.000Z","path":"2020/02/10/Barney--css优化/","text":"CSS和HTML是一对基友，两者是密不可分的。没有HTML，CSS的表现没有载体。没有CSS，HTML就没有那么多的布局和样式了。那么，如何给HTML添加样式呢？ 添加样式 内联CSS，优点是不会阻断HTML的加载。缺点是会增加HTML文件的体积，同时不利于样式的管理和阅读，可读性不强。所以，一般只是首屏的关键CSS才会这样写。可以搜索css trigger具体了解用法。 Link标签 1&lt;link href='xxx.css' rel='stylesheet'&gt; 上面这种写法可以会阻断HTML的渲染，不会阻塞HTML的构建，具体流程参考关键路径 1&lt;link href='xxx.css' rel='stylesheet' media='none' onload='this.media=all'&gt; 上面这种写法，既不会阻塞HTML的构建，也不会阻塞渲染，算是异步加载css文件的异种pollyfill的手段。 1&lt;link rel='preload' href='xxx.css' as='style' onload='this.rel=stylesheet'&gt; 这种写法，也是异步加载，而且是官方提供的，但是各个浏览器的支持度不够高。 样式选择器独立选择器： 属性选择器 类选择器 ID选择器 标签选择器 伪类选择器 伪元素选择器 通用选择器 组合选择器： 分组选择器(a, b) 后代选择器(a b) 子选择器(a &gt; b) 相邻选择器 (a + b) 同辈选择器(a ~ b) 在使用选择器的时候，尽量避免嵌套多个选择器，因为选择器是从右到左，过多嵌套会加重计算。同时减少重流和重绘。会出发CSS重流重绘的元素可以参考：http://csstriggers.com. 关键渲染路径 上图是在没有JS的情况下，DOM和CSSOM的构建过程，可以看到，DOM和CSSOM是并行的，两个互不影响，而Render Tree的形成时间则是由两者中耗时最长的路径决定的。 而在有JS文件的情况下，由于JS会改变CSS和HTML。所以，JS会阻断HTML的DOM构建，而且，JS的执行是在CSSOM形成之后。所以，在有JS参与的情况，关键路径如下所示： 此时的Render Tree形成由路径上节点耗时的总和。所以，我们需要对关键路径进行优化。 减少HTML文件大小，使用HTTP Cache 将不必要的CSS文件只用异步加载，减少CSSOM的构建时间。 加载JS文件时，使用async 1&lt;script async src='xxx.js' /&gt; Critical CSS","tags":[{"name":"CSS","slug":"CSS","permalink":"https://liangbilin.github.io/tags/CSS/"}]},{"title":"软件工程","date":"2020-02-08T02:09:00.000Z","path":"2020/02/08/Barney--软件工程/","text":"1 软件工程的基本概念1.1 软件开发的基本策略 软件复用 软件复用包括代码的复用、原有的类库、工具函数的复用、模版的复用、设计的复用、框架的复用。使得开发效率变高、降低维护成本、提高产品质量。 分而治之 将一个工程分解为多个小的问题，分开处理。比如现在的前后端分离，就是讲一个具体的工程分为了前端和后端，前后端商量好接口的定义，就可以分开独自开发，最后再联调。这样的优点是专注小的模块，同时可以多个开发人员同时开发，缩减开发周期。 逐步演进 比如敏捷开发，先做出一个可以勉强上线，满足用户大部分功能的产品，然后再根据需求不断的迭代，使产品更好的满足用户的需求。 优化折中 一个好的产品，是多方面的考量的。从开发的角度，需要高性能、代码符合规范、安全。对于用户来说，是易懂、容易操作、满足用户的某些需要。但是有时候，为了高性能可能会带来更高的开发成本，这个时候，这个成本是否值得，就是一种考量了。如果花更多的成本去提高性能能带来更多的收益，当然是好的。如果不能，那提高性能的代价就值得商榷了。 2 编程过程与规范Google各个代码的代码规范：https://github.com/google/styleguide，可以参考一下。 如何更专业的沟通和提问：https://github.com/seajs/seajs/issues/545 2.1 模块化程序设计即将一个大的程序按照功能或其它分解的方式，拆解成一个个小的模块。（分而治之的策略），优点是： 降低程序设计的复杂度 提高模块的可靠性和可复用性 缩短产品开发周期 易于维护和功能扩展 如何划分：按照业务功能：登陆模块、主页面模块、其他具体活动的模块。 按照系统层次划分：业务层、数据存储层等等。 按照代码稳定性，将不容易改变的、通用的代码放在一个个独立的模块，然后其他易变的模块去引用。比如接口请求模块是不易变的，而某个具体的活动是易变的。 每个划分都应该遵循单一原则。单一原则 !== 单一功能，而是说只有一个引起变化的原因。 2.2 try…catch对于能够预知到可能会发生错误的代码，进行一场捕获，如果发生异常，可以在catch中处理异常。 2.3 实例：生命游戏2.4 code reviewJS代码规范 2.5 代码性能优化代码优化考虑的因素： 在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率 以提高程序的全局效率为主、提高部分代码效率为辅 在优化程序效率时，应先找出限制效率的“瓶颈” 先优化数据结构和算法，再优化执行代码 时间效率和空间效率可能是对立的，应当分析哪一个因素更重要，再作出适当的折中 从一开始就要考虑程序性能，不要期待在开发结束后再做一些快速调整 正确的代码比速度快的代码重要，任何优化都不能破坏代码的正确性 具体的代码优化步骤： 证明需要进行代码优化 -&gt; 找出需要优化的关键部分 -&gt; 测试代码 -&gt; 评测优化后的代码 具体实例：https://www.bilibili.com/video/av80893577?p=11 PS：可读性好的代码才能方便修改，好修改的代码才能有更久的生命力。好的软件都是迭代出来的。 3 测试3.1 单元测试测试用例： 测试用例值、预期结果、前缀值（即必要的输入或者条件状态）、后缀值 测试用例设计： 具有代表性和典型性 寻求系统设计和功能设计的弱点 基友正确输入也有错误和异常输入 考虑用户实际的诸多使用场景 3.2 黑盒测试等价类划分：将每个输入域尽可能的少的若干子域，然后每个子域两两互不相交。这些子域都是有意义、合理的输入，是为了验证代码是否完整的实现了需求，这叫有效等价类。还有一些事无意义的、不合理的输入叫无效等价类，是为了验证当错误发生或者用户不合理操作的时候，代码对这些异常的处理，是为了验证系统的健壮性。在编写代码的时候，可以使用代码来mock一些不合理的数据输入和输出来验证无效等价类。 1234567891011// 比如现在有一个需求是：写一个函数，判断输入的三个三角形的边的值是否构成一个三角形，如果构成三角形，判断它是什么三角形，三角形包括：等边三角形、等腰三角形、直角三角形、普通三角形// 那么这个时候的等价有效类是：等边三角形、等腰三角形、直角三角形、普通三角形// 无效等价类是：非三角形// 测试用例可以为：// 1. a = 3, b = 3, c = 3 等边三角形// 2. a = 3, b = 3, c = 4 等腰三角形// 3. a = 3, b = 4, c = 5 直角三角形// 4. a = 3, b = 4, c = 6 普通三角形// 5. a = 3, b = 4, c = 9 非三角形 边界值分析：将输入设定为程序的输入限制的边界，然后查看是否出错。若有多个边界值，则每次值选择一个边界值进行测试。其他有边界值的输入为正常输入。 1// 比如边界值是100的时候，用该输入99、100、101这三个边界值，判断输出是否符合预期 健壮性测试：将输入设定为程序输入限制之外的值，判断程序是否对其有合适的处理。 3.3 白盒测试白盒测试更多是需要人工的去查看代码，判断代码逻辑是否正确，这个一般在code review的时候做。 4 软件过程 4.1 需求的提出在产品提出需求的时候，就需要考虑到这两个方面： 需求的可行性 需求的所带来的预期收益 4.2 开发 软件开发过程就是根据需求说明，然后设计系统结构、接口、组件，同时做好前后端接口设计，形成一个软件设计说明书。然后得到根据软件设计说明书进行开发。","tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://liangbilin.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"python包和模块——创建和安装","date":"2020-01-17T16:00:00.000Z","path":"2020/01/18/Billy--Python包和模块—创建和安装/","text":"在计算机程序的开发过程中,随着程序代码越写越多,在一个文件里代码就会越来越长,越来越不容易维护。为了编写可维护的代码,我们把很多函数分组,分别放到不同的文件里,这样,每个文件包含的代码就相对较少,很多编程语言都采用这种组织代码的方式。在Python中,一个.py文件就称之为一个模块(Module)。 包是一个有层次的文件目录结构,它定义了由n个模块或n个子包组成的python应用程序执行环境。通俗一点:包是一个含__init__.py文件、模块文件和其他子包的目录。 模块的创建比较简单,直接创建一个.py文件即可。创建包需要创建一个包含__inint__.py文件的目录(python 3.3版本以后,即便没有这个inint.py文件也可以)。 (一) 模块和包的基本信息&lt;1&gt; 名称信息模块名称就是不包含.py后缀的模块文件名称。例如有一个模块文件为test.py,该模块名称即为test。 包名称就是该包文件目录的名称。 &lt;2&gt; 查看模块和包的文件路径使用__file__内置属性来进行查看,如需要查看标准模块os的路径,可以使用下面的命令: 1os.__file__ &lt;3&gt; 查看模块的接口内容一种方法是查看模块的源码,如使用的是 PyCharm 这一 IDE 时,可以用Ctrl + 鼠标点击模块文件的方式打开源码,进行查看。另一种方法是,使用内置方法dir()来进行查看。 1print(dir(os)) (二) 检索路径&lt;1&gt; 查看当前检索路径将按照优先级顺序,打印模块和包的检索路径。 12import sysprint(sys.path) &lt;2&gt; 修改检索路径从上面可以看到,sys.path保存的路径是一个列表形式。因此,能够使用append方法添加新的路径。 12import syssys.path.append(\"path/to/your/packages\") (三) 导入模块当第一次导入模块的时候,会自动执行一次模块。 第一种方式,使用import导入,用 as 添加别名。 12345# 导入包import Package as p# 导入包/模块import Package.Module as m 第二种方式,使用from Packages import * 两种方式在调用包和模块资源的时候存在区别,一般为了避免命名空间出现混乱,建议使用第一种方式进行导入。 (四) 三方包和模块的安装对于单一文件的模块,只需要将其拷贝到sys.path包含的路径中即可使用。对于多文件甚至需要三方库依赖的包或模块,则需要使用特定的方式进行安装。 &lt;1&gt; 本地安装将模块或包的文件下载到本地进行安装,由于历史原因,这些文件可能为.egg或者.whl后缀形式。 其中.egg是setuptools项目引入的模式,需要先安装setuptools,然后以该三方库的easy_install工具进行安装。 .whl本质是一个zip压缩格式,它的引入是为了取代.egg。如果所下载的.whl是由distutils项目打包的,则可以直接安装(这是由于distutils是python官方项目,被引入了标准库中),而该.whl是由setuptools打包的,则需要先安装setuptools,再进行安装。 比如,使用easy_install安装.egg文件: 1easy_install xxx.egg 又比如,使用pip安装.whl文件: 1pip install xxx.whl 在某些时候,下载的一个安装包,解压缩后,存在一个setup.py文件,则可以如下安装: 1python setup.py install 需要注意的是,尽管这里所说是本地安装,然而所安装的包往往会存在依赖,而这些依赖的文件并没有被包含在所下载的文件中,只是注明了依赖关系而已。所以需要网络,自动下载。 &lt;2&gt; 在线安装对应本地安装,在线安装也可以使用easy_install和pip两种方式,这里介绍比较常用的pip方式。 使用形式 1pip install package_name 更换安装源 默认的安装源为python官方,但由于这个服务器在国外,所以导致网速较慢。因此,可以选择国内的一些镜像安装源。 清华:https://pypi.tuna.tsinghua.edu.cn/simple豆瓣:http://pypi.douban.com/simple/ 一次性修改安装源: 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple package_name 永久修改安装源(Windows系统): 接在系统盘下,user目录中,创建一个pip目录,如:C:\\Users\\xx\\pip; 在新建的目录下,创建一个名为pip.ini的文件,内容如下: 12[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 永久修改安装源(Linux系统): 在当前用户的目录下创建.pip文件夹 然后在该目录下创建一个名为pip.conf的文件,内容如下: 123[global]trusted-host &#x3D; pypi.douban.comindex-url &#x3D; http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple","tags":[{"name":"软件教程","slug":"软件教程","permalink":"https://liangbilin.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"}]},{"title":"作用域与闭包","date":"2020-01-15T03:06:12.000Z","path":"2020/01/15/Barney--作用域与闭包/","text":"先编译后执行JavaScript虽然是动态语言,但是在执行的时候,也仍然是按照先编译后执行的顺序来解析代码的。codeExample_1就能证明这种结果。 1234// codeExample_1var greeting = 'hello';console.log(greeting);greeting = .'Hi'; // 错误代码,会报错 用node去执行段代码,会发现,不会打印hello再报错,而是直接报错。因为编译器在遇到错误代码的时候就报错了,从而导致整个程序都无法执行。 词法作用域在编译时,变量的作用域就已经确定,这样的作用域称为词法作用域。而从一个作用域拿到另一个作用域中的变量的方法,则称为闭包。在代码执行的时候,每当遇到一个函数或者包含有let、const声明的变量的{...}就会生成一个块级作用域。所以,作用域最后会形成一个作用域里面嵌套多个子作用域。子作用域可以使用父作用域中的变量,但是父作用域不能使用子作用域中的变量。 在作用域中查找变量有以下几个规则: look up 当一个作用域中使用了一个变量的时候,会优先在当前作用域去查找这个变量的值,如果没有找到这个变量,就会一直往父作用域中查找,知道找到为止或者到顶级作用域为止。当然,这个规则其实是一种抽象,其实当前作用域能否拿到这个作用域中的变量的值在编译时期就已经知道了,不会在运行的时候再去look up。 Shadowing 当一个作用域声明了一个和父作用域中相同的变量名时候,由于look up规则,会优先使用当前作用域中的变量声明的值,从而造成了shadow的效果。 变量提升函数声明和变量声明在编译器编译的时候的行为是不一样的。编译器在遇到函数声明时,会连带着变量声明和变量赋值,所以函数声明可以后声明先使用。 123const a = getNumber(1, 2);function getNumber(a, b) &#123; return a + b; &#125; 但是变量声明,会将变量的声明语句和赋值语句分开,声明语句会先执行,赋值语句后执行,而var声明的变量会默认给一个初始值undefined,let和const声明的语句则不会。所以var声明的变量,可以先使用声明,但是在声明语句之前的值是undefined,而let和const在声明之前使用则会报错,因为他们没有给默认的初始值。 1234567console.log(a); // undefinedconsole.log(b); // Error,会导致程序崩溃var a = 1;let b = 2;console.log(a); // 1console.log(b); // 2 let、var、const的区别 let和const会生成新的作用域,var不会 var、let声明的变量可以改变,const声明的变量必须一开始就赋初始值,且不会改变 var不适合用于for…loop中,因为没有生成新的作用域,会导致所有迭代变最后都是一个值 const不适用于有变量for(;;i++)的循环 1234567891011for (const i = 0; i &lt; 5; i++) &#123; .... &#125;// 相当于&#123; const $i = 0; for (; $i &lt; 5; $i++) &#123; const i = $i; ... $i++; // const不能重新赋值 &#125;&#125; 闭包 Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope. 比如: 1234567891011function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 上面这段代码很好的展示了什么是闭包。按照作用域的规则,正常情况下,我们是拿不到foo作用域中的a的。当foo()执行完之后,垃圾回收机制会将foo作用域回收,那么其内部声明的变量以及函数都会被回收,但是由于bar被return了,导致仍然有baz指向了这段函数,所以bar和它的词法作用域才没有被垃圾回收,因此baz才能正常执行,也能拿到a。 12345678910111213function foo () &#123; var a = 2; function baz() &#123; console.log(a); &#125; bar(baz);&#125;function bar(fn) &#123; fn();&#125; 按照作用域的规则,bar是无法拿到foo中的变量a的。但是,当baz作为函数传递给bar时,由于baz能拿到foo中的a。此时bar也可取到a了,这就是闭包。闭包在JS中随处可见,但是闭包也有一个问题就是,无法及时释放内存,如果存在大量闭包,会导致大量内存无法释放,占用资源,甚至导致内存泄漏。所以,在使用闭包结束之后,应该将闭包清理掉,如: 12345678910111213function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2baz = null; // baz指向了null,那bar指向的那段函数就没有再被引用,将会被垃圾回收机制清理掉,从而释放内存","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"组学数据分析中 Gene ID 转换","date":"2020-01-12T16:00:00.000Z","path":"2020/01/13/Billy--组学数据分析中基因ID转换/","text":"&lt;1&gt; 使用R包org.Hs.eg.db进行转换安装Bioconductor源的第三方R包 123source(\"http://bioconductor.org/biocLite.R\")biocLite(\"org.Hs.eg.db\")library(org.Hs.eg.db) 查看org.Hs.eg.db数据对象包含的各大主流数据库的数据。 1keytypes(org.Hs.eg.db) [1] “ACCNUM” “ALIAS” “ENSEMBL” “ENSEMBLPROT” “ENSEMBLTRANS”[6] “ENTREZID” “ENZYME” “EVIDENCE” “EVIDENCEALL” “GENENAME”[11] “GO” “GOALL” “IPI” “MAP” “OMIM”[16] “ONTOLOGY” “ONTOLOGYALL” “PATH” “PFAM” “PMID”[21] “PROSITE” “REFSEQ” “SYMBOL” “UCSCKG” “UNIGENE”[26] “UNIPROT” 使用 select 函数能够提取其中部分内容。例如,提取”ENSG00000130720”, “ENSG00000103257”, “ENSG00000156414”, “ENSG00000144644”, “ENSG00000159307”, “ENSG00000144485” 这六个基因的SYMBOL和GENENAME信息。 123ensids &lt;- c(\"ENSG00000130720\", \"ENSG00000103257\", \"ENSG00000156414\", \"ENSG00000144644\", \"ENSG00000159307\", \"ENSG00000144485\")cols &lt;- c(\"SYMBOL\", \"GENENAME\")select(org.Hs.eg.db, keys=ensids, keytype=\"ENSEMBL\", columns=cols) ENSEMBL SYMBOL GENENAME1 ENSG00000130720 FIBCD1 fibrinogen C domain containing 12 ENSG00000103257 SLC7A5 solute carrier family 7 member 53 ENSG00000156414 TDRD9 tudor domain containing 94 ENSG00000144644 GADL1 glutamate decarboxylase like 15 ENSG00000159307 SCUBE1 signal peptide, CUB domain and EGF like domain containing 16 ENSG00000144485 HES6 hes family bHLH transcription factor 6 因此,可以利用这种方式来进行基因ID的转换。例如上面代码,我们有几个ensembl的基因ID号,想找它们所对应的gene名和缩略词简称,就通过select函数来搞定。 当然,select 函数还可以应用于信息的查看,例如想要查看BRCA1基因的GO、ENTREZID等等信息: 1select(org.Hs.eg.db, keys=\"BRCA1\", keytype=\"SYMBOL\", columns=c(\"ENSEMBL\",\"UNIGENE\",\"ENTREZID\",\"CHR\",\"GO\",\"GENENAME\")) SYMBOL ENSEMBL UNIGENE ENTREZID CHR GO EVIDENCE ONTOLOGY GENENAME1 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0000151 NAS CC BRCA1, DNA repair associated2 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0000724 IDA BP BRCA1, DNA repair associated3 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0000729 TAS BP BRCA1, DNA repair associated4 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0000731 TAS BP BRCA1, DNA repair associated5 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0000732 TAS BP BRCA1, DNA repair associated6 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0000800 IDA CC BRCA1, DNA repair associated7 BRCA1 ENSG00000012048 Hs.194143 672 17 GO:0003677 TAS MF BRCA1, DNA repair associated &lt;2&gt; 使用R包clusterProfiler的bitr方法进行转换安装Bioconductor源的第三方R包 123source(\"http://bioconductor.org/biocLite.R\")options(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")biocLite(\"clusterProfiler\") 进行ID转换 12345library(\"clusterProfiler\")gene.df &lt;- bitr(gene, fromType = \"ENTREZID\", #fromType是指你的数据ID类型是属于哪一类的 toType = c(\"ENSEMBL\", \"SYMBOL\"), #toType是指你要转换成哪种ID类型,可以写多种,也可以只写一种 OrgDb = org.Hs.eg.db)#Orgdb是指对应的注释包是哪个head(gene.df) &lt;3&gt; 使用R包AnnotationDbi进行转换123456library(AnnotationDbi)mySymbols &lt;- mget(gene, org.Hs.egSYMBOL, #这个是可以选择的,选择不同,转换的ID类型也不一样 ifnotfound&#x3D;NA)# 转换成Symbol IDhead(mySymbols)class(mySymbols) &lt;4&gt; 使用在线网页工具进行转换 DAVID: The Database for Annotation, Visualization and Integrated Discover http://david.abcc.ncifcrf.gov/conversion.jsp. 挺强大的一个工具,不过可能就是速度有点慢…还有一个缺点就是数据不能及时更新。 Biomart http://www.biomart.org/biomart/martview/65c2ea6c079d1b85820fa5bbf5af62b5 非常不错的工具,定期发布新版本,而且可以将数据下载到本地进行操作,推荐。 BioDBnet http://biodbnet.abcc.ncifcrf.gov/db/db2db.php Hyperlink Management System (HMS) http://biodb.jp/ BridgeDB http://www.biomedcentral.com/1471-2105/11/5 Uniprot 也提供了比较好的转换工具 http://www.uniprot.org/ (ID Mapping) KEGG 的API http://www.kegg.jp/kegg/rest/keggapi.html (conv) 参考资料https://vip.biotrainee.com/d/109-entrez-id","tags":[{"name":"Database","slug":"Database","permalink":"https://liangbilin.github.io/tags/Database/"},{"name":"组学分析","slug":"组学分析","permalink":"https://liangbilin.github.io/tags/%E7%BB%84%E5%AD%A6%E5%88%86%E6%9E%90/"}]},{"title":"window对象","date":"2020-01-07T03:51:00.000Z","path":"2020/01/07/Barney--window对象/","text":"window对象是全局对象，里面有很多可以用于前端交互的属性，下面将一一介绍。 1. screen 对象screen对象可以获取到用户的屏幕信息，主要有以下四个通用属性，其他属性不同的浏览器支持度不同，所以就不作介绍了。 获取屏幕的宽高，screen.width &amp;&amp; screen.height、widnow.screen.width &amp;&amp; window.screen.height。 获取屏幕的可用宽高，screen.availWidth &amp;&amp; screen.availHeight、widnow.screen.availWidth &amp;&amp; window.screen.availHeight。 2. location 对象属性： 属性 描述 href 设置或返回完整的URL hash 设置或返回从井号 (#) 开始的 URL（锚）。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的端口号 protocol 设置或返回当前URL的协议 search 设置或返回从问好（？）开始的URL，及查询部分 方法：| 方法 | 描述 || ——– | ——————————————- || assign(url) | 加载新的文档 || reload(bool) | 重新加载当前文档 || replace(url) | 用新的文档替换当前文档（* 不会有history记录） | 3. History 对象History 对象最初设计来表示窗口的浏览历史。但出于隐私方面的原因，History 对象不再允许脚本访问已经访问过的实际 URL。唯一保持使用的功能只有 back()、forward() 和 go() 方法。history又一个length属性表示浏览器历史列表中浏览记录的数量。 方法： 方法 描述 back(numer = 1) 加载指向history中当前URL前number个URL forward(number = 1) 加载指向history中当前URL后number个URL go(url) 前往history中的某个具体页面 4. Navigator 对象Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。不过一般不太常用，因为在http请求中，一般也都会有关于浏览器的常用属性。 具体属性见w3C: https://www.w3school.com.cn/jsref/dom_obj_navigator.asp 5. 其他常用的window属性与方法属性： 属性 描述 innerHeight、innerWidth get文档显示区域的宽度和高度 pageXOffset、pageYOffset set || get 页面相对窗口显示区域的x、y方向的位置 方法： 方法 描述 setTimeout、clearTomeout 在指定时间后加入事件队列 setInterval、clearInterval 按照指定的时间，周期性的将内部的方法加入事件队列 scrollTo 将内容滚动到指定的坐标 其实window对象整体的知识点是简单的，关键是如何使用。比如常见的回退定位就是通过在前后两个页面中，通过url中的query信息传递的位置浏览页面的位置信息。而当用户回到浏览页面时，浏览页会从url中拿到上一次进入页面的时候，已经浏览到的位置。然后将页面滚动到用户已经浏览到的位置。这样就可以实现回退定位的操作，提升用户体验。 还比如，setTimeout其实是可以替代setInterval，而且有的时候，setTimeout代替setInterval的效果要比它本身更好。因为setInterval只是周期性向事件队列添加事件。但如果事件队列中已经有了这个setInterval要添加的事件，那么setInterval就不会再添加事件到事件队列里了。如果遇到复杂的计算并且周期又很短，就可能导致失帧。也就是说，有一些步骤的是不会加入到事件队列，从而丢失的。具体可以参考以这篇文章：https://juejin.im/post/5dac26206fb9a04dea5df84f 再比如，innerHeight和innerWidth可以让我们根据可以展示的区域的大小做一定的适配，规定一些基础宽度大小，比如html的font-size的大小，从而达到响应式的效果。 下周计划，看完了you don’t know JavaScript yet的作用域这一块，所以下个周的内容应该是重点整理这个知识点。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"JS中的事件机制","date":"2020-01-05T15:47:47.000Z","path":"2020/01/05/Barney--JS中的事件机制/","text":"js中的事件机制由于js是单线程的,所以在遇到事件绑定、ajax请求的时候回造成阻塞,因此就产生了异步操作。可以让js的主线程持续工作。在这个过程中主要有三个东西,一是主线程、二是任务队列、三是回调函数。 主线程就是不断地从任务队列里面取出一个事件去执行,在执行完这个时间之后再去任务队列取事件。如果任务队列没事件就会处于等待状态。 主线程取到任务队列里的事件之后会将事件的上下文放在调用栈中,然后一步一步执行里面的操作。如果遇到异步操作就会交给浏览器内核的其他模块进行处理,等处理完之后,再将回调函数放入任务队列汇总。 任务队列是用来存放事件的,当主线程完成当前操作之后,就会从这里面取事件执行。任务队列分为macro-task和micro-task(micro-task只有一个)两种队列,主线程会先调用marco-task任务队列,直到函数调用栈中当前macro-task执行上下文结束,再执行micro-task中的任务,执行完micro-task中的事件后又去执行macro-task中的事件,如此反复。 macro-task:script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task: process.nextTick, Promises, Object.observe, MutationObserver 回调函数是在异步操作执行完之后,放入任务队列让主线程执行的函数。 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// democonsole.log('golb1');setTimeout(function() &#123; console.log('timeout1'); process.nextTick(function() &#123; console.log('timeout1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout1_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout1_then') &#125;)&#125;)setImmediate(function() &#123; console.log('immediate1'); process.nextTick(function() &#123; console.log('immediate1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate1_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate1_then') &#125;)&#125;)process.nextTick(function() &#123; console.log('glob1_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob1_promise'); resolve();&#125;).then(function() &#123; console.log('glob1_then')&#125;)setTimeout(function() &#123; console.log('timeout2'); process.nextTick(function() &#123; console.log('timeout2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout2_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout2_then') &#125;)&#125;)process.nextTick(function() &#123; console.log('glob2_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob2_promise'); resolve();&#125;).then(function() &#123; console.log('glob2_then')&#125;)setImmediate(function() &#123; console.log('immediate2'); process.nextTick(function() &#123; console.log('immediate2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate2_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate2_then') &#125;)&#125;) 这个例子看上去有点复杂,乱七八糟的代码一大堆,不过不用担心,我们一步一步来分析一下。 第一步:宏任务script首先执行。全局入栈。glob1输出。 第二步,执行过程遇到setTimeout。setTimeout作为任务分发器,将任务分发到对应的宏任务队列中。 第三步:执行过程遇到setImmediate。setImmediate也是一个宏任务分发器,将任务分发到对应的任务队列中。setImmediate的任务队列会在setTimeout队列的后面执行。 第四步:执行遇到nextTick,process.nextTick是一个微任务分发器,它会将任务分发到对应的微任务队列中去。 第五步:执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中,但是它构造函数中的方法会直接执行。因此,glob1_promise会第二个输出。 ) 第六步:执行遇到第二个setTimeout。 第七步:先后遇到nextTick与Promise 第八步:再次遇到setImmediate。 这个时候,script中的代码就执行完毕了,执行过程中,遇到不同的任务分发器,就将任务分发到各自对应的队列中去。接下来,将会执行所有的微任务队列中的任务。 其中,nextTick队列会比Promie先执行。nextTick中的可执行任务执行完毕之后,才会开始执行Promise队列中的任务。 当所有可执行的微任务执行完毕之后,这一轮循环就表示结束了。下一轮循环继续从宏任务队列开始执行。 这个时候,script已经执行完毕,所以就从setTimeout队列开始执行。 setTimeout任务的执行,也依然是借助函数调用栈来完成,并且遇到任务分发器的时候也会将任务分发到对应的队列中去。 只有当setTimeout中所有的任务执行完毕之后,才会再次开始执行微任务队列。并且清空所有的可执行微任务。 setTiemout队列产生的微任务执行完毕之后,循环则回过头来开始执行setImmediate队列。仍然是先将setImmediate队列中的任务执行完毕,再执行所产生的微任务。 当setImmediate队列执行产生的微任务全部执行之后,第二轮循环也就结束了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"超精华生信ID总结--转载于生信技能树","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/Billy--超精华生信ID总结--转载于生信技能树/","text":"要想成为一名合格的生物信息工程师,首要条件就是能在各大生信数据库中自由翱翔。目前的生信数据库大体可以分为三类: (1) 核酸数据库(例如:GenBank,Ensembl等) (2) 蛋白质数据库(例如:Uniprot,PDB等 (3) 专用数据库(例如:KEGG,GO,GEO等等) 可以说数据库的种类和数量都非常的繁多!同时,每个数据库都有自己独特的检索ID编号(例如Entrez ID,Ensembl ID 等等),也就是说同一个基因在不同的数据库中会有不同的名称。这么多生信ID和数据库看着真是眼花缭乱。。。我们几乎不可能全部都记住!所以,为了提高学习效率,我们首先来看看生信领域最流行使用的数据库有哪些吧,然后再针对性地去学习相应的数据库和它们的编号系统! (一) 各大生信资源的使用流行程度PLOS-ONE上的一篇文章利用bioNerDS工具分析了Pubmed的 5,411,968篇文献的语料库,最终得到下列生信领域的资源使用排名: Mention Level Document Level GO 2.08 R 0.29 R 1.17 GO 0.19 BLAST 0.62 BLAST 0.16 PDB 0.43 GenBank 0.13 KEGG 0.43 GEO 0.09 GenBank 0.35 KEGG 0.09 Ensembl 0.24 PDB 0.08 Pfam 0.20 Cluster 0.06 Cluster 0.18 UniProt 0.05 从这张表,我们可以明显发现生信领域的NCBI-GenBank, UniProt, GO, KEGG和GEO等数据库的使用频率都非常高。所以,我们的学习就从这些主要的数据库开始! (二) 生信数据库的霸主-NCBI以及Entrez检索系统谈到生信数据库,就不得不提非常著名的NCBI。NCBI是什么呢 NCBI(National Center for Biotechnology information)即美国国家生物技术信息中心,由美国国立卫生医学图书馆(NLM)于1988年建立。该中心的任务是:为储存和分析分子生物学、生物化学、遗传学知识创建自动化系统;从事研究基于计算机的信息处理过程的高级方法,用于分析生物学上重要的分子和化合物的结构与功能;促进生物学研究人员和医护人员应用数据库和软件;努力协作以获取世界范围内的生物技术信息。 所以,需要明确的是,我们常说的NCBI是一个机构组织,而不是数据库喔。那么,我们登陆的NCBI的网页(https://www.ncbi.nlm.nih.gov/) 所访问的数据库和NCBI是什么关系呢?那就不得不提Entrez啦! Entrez是归属于NCBI的一个综合的文本检索引擎系统。这个检索引擎整合了PubMed数据库的生物医学文献与其他39个文献和分子数据库(例如GEO,Entrez Gene等,这些数据库基本涵盖了DNA和蛋白质序列,结构,基因,基因组,遗传变异和基因表达方面的数据)。 所以,我们通常所说的检索NCBI数据库,其实就是在检索Entrez这个引擎系统所整合的生信数据库。简而言之就是,NCBI组织建立了Entrez,Entrez整合了各大数据库的入口,方便我们进行数据库检索。 了解了NCBI和Entrez的关系之后,我们来看看还有哪些常用的数据库吧。 假设我们现在想检索一个名字叫做TP53的基因,了解它的故事,我们应该去哪个数据库呢?同时,TP53只是这个基因多个名称中的一个(它还有其它的名字,例如:7157,HGNC:11998等等),所以这些不同的基因名称之间又有什么区别呢?OK , 让我们一一道来! 首先,要想快速了解一个Gene并且获取和它相关链接的外链数据库,我们首推Entrez Gene数据库!什么是Entrez Gene数据库呢? (三) Gene查找好帮手-Entrez Gene数据库Entrez Gene数据库是Gene查找的好帮手,一般情况下我们如果想快速了解一个Gene的基本信息,可以直接进入(https://www.ncbi.nlm.nih.gov/gene/) 进行搜索。 NCBI的Gene数据库Entrez Gene数据库其实就是我们现在指的NCBI中的Gene数据库(这两个名字指的是同一个数据库)Gene数据库建立的目的是,整合各个方面和基因相关的数据资源,构建一个能够使人快速访问并且获取特定基因信息的访问入口,从而为数据交换以及科学家们的研究提供便利。它的数据包含了和基因相关的序列,结构,以及基因表达等等的信息,是基因资源的综合数据库。 我们输入TP53之后会得到这样的检索结果界面: 在标题下面,我们可以看到Gene ID: 7157 这一行,7157就是我们耳熟能详的Entrez Gene ID啦,它是目前国际上最权威的Gene ID编号! Entrez Gene ID 又可以称为Entrez ID ,也是我们通常所说的Gene ID 。它是来源于Entrez Gene数据库的编号系统。每个Gene数据库中的记录数据都会被分配一个唯一的Gene ID编号。编号的格式就是一串数字,例如:7157,2131这样的。同时,Gene ID的数字并不是连续分配的(也就是说有间隔)。Gene ID的分配规则:Gene ID通常被分配给RefSeq数据库中注释为基因的对象,当然,并不是所有的Gene ID都基于RefSeq,如果RefSeq数据库中没有记录,也可以指定GeneID。需要注意的是,Gene ID编号的命名是具有物种特异性的(例如,编码人的肌营养不良蛋白的基因和编码小鼠肌营养不良蛋白的基因,它们俩的Gene ID在Gene数据库中编号是不一样的,分别是:1756 和 13405)。 关于Entrez Gene数据库,我们还可以来看看一个统计数字 Entrez Gene 中目前一共有61118条人类的Gene ID记录(记录包括功能基因,假基因,预测基因等等),68389条小鼠Gene ID的记录,可以说是非常全面了。 同时,Gene数据库中的ID记录是每日更新一次,可以保证我们每天看到的Gene ID记录都是最新的啦 Entrez Gene数据库现在既然这么厉害,那它最初的时候是什么模样呢,聊聊历史吧 Gene数据库首次公开是在1999年,那时它的名字还不叫Gene,而是叫做LocusLink(曾用名,现已不再使用)。当时刚刚发表的LocusLink只包含了人类这一个物种的数据信息,而且只有不多于9000条的记录。LocusLink的外链数据库也只有dbSNP, OMIM, RefSeq, GenBank, 和UniGene。(见下图) 而到2003年,Entrez Gene数据库发布,Gene数据库的数据已经包含了10个物种,195000条记录,外链数据库也增加了许多,包括dbSNP, Ensembl, the HUGO Gene Nomenclature Committee (HGNC), GEO, Map Viewer等等。至今,随着生物大数据的爆发式增长,Gene数据库包含的数据记录与外链数据库也越来越多,已经成为生信工作者必不可少的工具之一。 可见,我们的Enrez Gene数据库的发展也是很迅速哒! 了解完Entrez Gene之后,我们再接着往下看,出现了Summary这一栏,首先映入眼帘的是三行 Official Symbol:TP53 provided by HGNC Official Full Name:tumor protein p53 provided by HGNC Primary source HGNC:HGNC:11998 不约而同,这三行的内容来源均是HGNC,什么是HGNC呢? (四) 人类基因命名委员会-HGNC 人类中大多数基因的命名,是由HGNC(HUGO Gene Nomenclature Committee,人类基因命名委员会)来完成的。 HGNC(HUGO Gene Nomenclature Committee)即人类基因命名委员会,是由美国国家人类基因组研究所(NHGRI)和英国惠康信托基金(Wellcome Trust)共同出资成立的非盈利机构。早在二十世纪60年代的时候,科学家们就意识到基因规范命名的重要性。于是1979年,在爱丁堡的人类基因组会议(HGM)上,Phyllis J. McAlpine博士所组成的命名委员会首次提出了人类基因命名规范。2007年9月,HGNC搬迁到欧洲生物信息学研究所(EBI)。目前,HGNC可以说是国际上非常权威的人类基因命名组织了目前,HGNC已经批准了超过41500个Gene Symbol ,其中超过19190个基因属于蛋白质编码基因,超过 7300个基因属于非编码RNA的基因,同时HGNC还为假基因以及基因组特征命名。HGNC也允许个人在遵循命名规范的前提下,向他们提交Gene Symbol的命名。 所以,刚才我们看到的Official Symbol(Gene Symbol),Official Full Name,HGNC:ID的含义分别是: HUGO Gene Symbol:HUGO Gene Symbol(也叫做HGNC Symbol,即基因符号)是HGNC组织对基因进行命名描述的一个缩写标识符(如:TP53),这些基因符号都是唯一的。 Gene Name:Gene Name是经过HGNC批准的全基因名称;对应于上面批准的符号(Gene Symbol)。例如TP53对应的Gene Name就是:tumor protein p53 。 HGNC ID:HGNC ID是HGNC数据库分配的基因编号,每一个标准的Symbol都有对应的HGNC ID 。我们可以用这个编号,在HGNC数据库中搜索相关的基因。例如:HGNC:11998有时候HGNC会对一些已经命名过的基因进行重新审查和重新命名,以确保新的基因命名在描述基因功能方面更加的准确。当一个基因被HGNC分配了新的Gene Symbol时,它之前的命名,会被当作同义词继续使用,所以一般建议使用HGNC ID而不是HGNC Symbol来作为我们处理数据中的唯一标识符。 同时,需要明确的是,因为HGNC只对人类基因进行命名,而且并不是所有的基因都有Official Symbol。所以如果基因缺少HGNC提供的Gene Symbol ,Entrez Gene数据库中的Official symbol就会变成Gene Symbol,并且Gene Symbol的编号会变成LOC前缀+Entrez ID,例如:LOC4333818 关于基因命名的组织委员会: 除了人类之外,对于一些典型的模式物种而言,也有相关的命名委员会。小鼠(mouse)的基因命名是来源于MGNC(可访问MGI数据库),大鼠(rat)基因命名来源于RGNC(可访问RGD数据库),斑马鱼的基因命名来源于ZFIN。还有一些其它物种的基因命名,基本就来源于NCBI的Gene数据库和Uniprot数据库。如果有些基因这些数据库里都没有命名,那么一般会直接从一些典型的模式物种(例如小鼠,斑马鱼等)的同源基因命名中引进。 了解完HGNC之后,回到刚才的话题,在TP53的检索结果接着向下看,会看到See related这一行,它提供了和TP53这个基因相关的外链数据库的连接。即Ensembl ,MIM以及Vega 。 Ensembl:ENSG00000141510 即Ensembl数据库的ID编号,MIM:191170是来源于OMIM数据库(Online Mendelian Inheritance in Man ,人类孟德尔遗传在线数据库)的编号。Vega:OTTHUMG00000162125来自Vega数据库(Vertebrate Genome Annotation,脊椎动物基因组注释 ) 其中,Ensembl ID可以说是非常常见了,基本做生信的人都要接触。所以,让我们来详细了解一下Ensembl数据库! (四) Ensembl计划首先看看Ensembl是什么 Ensembl基因组数据库项目是欧洲生物信息研究所和Wellcome Trust Sanger研究所之间的一个联合科学项目,该项目于1999年启动,以应对即将完成的人类基因组计划。Ensembl旨在为遗传学家,分子生物学家和其他研究我们自己的物种和其他脊椎动物和模式生物的基因组的研究人员提供集中资源。Ensembl是用于检索基因组注释信息的几种众所周知的基因组浏览器之一。 同时,需要注意的是,Ensembl中的基因组注释由两部分组成:计算机自动注释(例如全基因组的转录本注释)以及人工注释。 人工注释主要针对选定的物种(如:人类,小鼠,斑马鱼等等)。人工注释由Havana(Human and Vertebrate Analysis and Annotation)小组来完成。(我们在gtf注释文件中看到的HAVANA指的就是他们!HAVANA小组最开始是在Sanger研究所,2017年的时候迁往EBI了) 提到Ensembl,还有2个大名鼎鼎的计划也不得不提!那就是ENCODE和GENCODE Ensembl与ENCODE以及GENCODE计划之间的关系Ensembl是ENCODE计划的子项目。而GENCODE计划(由Sanger研究所维护)则是ENCODE项目的衍生品,它的目标是为ENCODE项目提供可用的人类基因组和小鼠基因组注释。Ensembl在ENCODE计划中的作用是,为人类基因组的组装提供计算机的自动注释信息,并且把这些自动注释的信息和来自HAVANA的人工注释信息进行合并。GENCODE中的人类和小鼠的基因组注释和Ensembl数据库是同步发行的。关于GENCODE的详细介绍,可以看本文最后的拓展阅读。 OK,了解完Ensembl数据库是做什么的之后,我们就可以使用Ensembl数据库来检索感兴趣的基因在基因组上的信息了。 我们在Ensembl中进行检索主要使用的是Ensembl Stable ID(也就是常说的Ensembl ID),例如:ENSG00000141510 。Ensembl ID也是有自己的命名规则的 Ensembl Stable ID的定义,格式,版本 Ensembl Stable ID是来源于Ensembl数据库的编号系统。它的命名由三部分组成: [species prefix][feature type prefix][a unique eleven digit number] [根据不同物种设置的前缀][数据所指类型【例如,蛋白质,基因】][一段特定的数字] 所以一个小鼠的基因在Ensmebl中的编号命名就应该是:ENSMUSG########### 。有时可以有不同的版本, 则在 Ensembl ID 后面加上小数点和版本号(例如:ENSG00000223972.5)。 Ensembl Stable ID版本号的更替是遵循一定规则的,具体可看:https://asia.ensembl.org/info/genome/stable_ids/index.html https://asia.ensembl.org/info/genome/compara/stable_ids.html 常用的物种前缀: 前缀 物种学名 ENSMUS Mus musculus (Mouse) ENSRNO Rattus norvegicus (Rat) ENSMZE Maylandia zebra (Zebra mbuna) MGP_LPJ_ Mus musculus (Mouse LP/J) FB Drosophila melanogaster (Fruitfly) ENS Homo sapiens (Human) 其他 … 类型前缀: 前缀 类型 E exon FM Ensembl protein family G Gene GT gene tree P protein R regulatory feature T transcript 关于Ensembl,还有一点很重要,那就是它的数据是定期更新的! Ensembl的数据更新Ensembl的数据大概2-3个月会更新一次,每次发布不同的版本的时候或者有什么计划安排,Ensembl都会在他们的博客或者Face-book,Twitter上发布消息(墙内的同学可以访问博客)。每次数据更新的范围涵盖新物种、新的基因集注释、新的变异数据等等。到目前为止Ensembl的数据版本已经发布到94版了(2018年10月) 如果想了解详细的版本信息和不同版本的数据可以访问: http://asia.ensembl.org/info/website/archives/index.htmlftp://ftp.ensembl.org/pub/ 既然数据更新了,那就有一个非常重要的问题,存储在Ensembl数据库中的Ensembl Stable ID是否会发生变动? OK,毕竟是大牛们做的项目,他们早就替我们想好啦。 Ensembl Stable ID 名副其实的“Stable”,一旦被分配之后,是尽可能的保持稳定不更改的。但是也有不稳定的情况存在: 一般情况下,如果某个基因数据发生一些小的改动,(例如某个基因对应的转录本信息发生变化),Ensembl Stable ID是不会变动的。但是Stable ID后面的Version会变化,就是在Ensembl ID 后面加上小数点和版本号。比如说:ENSG00000223972.5 。 不一般的情况下,例如基因组组装序列的一些改变较大,或者基因组注释的更新影响了某个基因的整体模式。这时,我们的Ensembl才会分配新的Ensembl Stable ID啦! 目前蛋白质家族的ID(fam),Ensembl EST基因的ID(ENSESTG)和 Genscan的ID (GENSCAN) 都是不稳定的。所以如果有小伙伴用了这些数据的Ensembl ID要注意保持这些ID的实时更新喔! 如果我们想看自己感兴趣的Gene在Ensembl中是否发生过ID变动,我们应该怎么做呢? OK,Ensembl是非常全面哒! ID历史版本转换Ensembl非常贴心的为我们提供了ID History Converter工具帮助使用者进行ID的新旧版本转换。有些数据的record里面,会有ID History一栏,帮助我们查看ID目前的版本和历史版本。例如:ENSG00000139618 的记录里就有 好啦,关于Ensembl和Ensembl ID的介绍就到这里,了解完Ensembl之后,我们接着向下看,发现有一个RefSeq status REVIEWED。 RefSeq status用于指明这个基因记录所对应的状态,REVIEWED说明它已经被专家审核。来看看RefSeq数据库。 (五) NCBI非冗余序列数据库-RefSeq RefSeq数据库,即RefSeq参考序列数据库,是美国国家生物信息技术中心(NCBI)提供的具有生物意义上的非冗余的基因和蛋白质等片段序列的数据库。 RefSeq的序列数据来源于大名鼎鼎的INSDC(International Nucleotide Sequence Database Collaboration,国际核苷酸序列数据库联盟),所以RefSeq非常权威和全面! 要知道现在是大数据时代,有非常多的数据,很多冗余的信息是没有用处的,而RefSeq能提供非冗余的序列,真的是非常有用了!我们来看看怎么在RefSeq中进行检索吧。 RefSeq 有一套特殊的 Accesion Number(就是我们通常用的RefSeq ID)让我们来进行检索。RefSeq数据库中的Accession number和GenBank数据库中的AC号格式不同。 RefSeq数据库Accession number的格式以两个字母开头,后跟一个下划线和六个或多个数字开头,例如:NT_123456:constructed genomic contigsNM_123456:mRNAsNP_123456:proteinsNC_123456:chromosomes ID的常见前缀 前缀 类型 说明 AC_ Genomic Complete genomic molecule, usually alternate assembly NC_ Genomic Complete genomic molecule, usually reference assembly NG_ Genomic Incomplete genomic region NW_ Genomic Contig or scaffold, primarily WGS NZ_ Genomic Complete genomes and unfinished WGS data NM_ mRNA Protein-coding transcripts (usually curated) NR_ RNA Non-protein-coding transcripts NP_ Protein Associated with an NM_ or NC_ accession 其它 …… …… 所以了解这些之后,我们就可以快乐的畅游在RefSeq的序列数据中了! 同时,RefSeq的数据是每日更新的,所以大大的保障了我们科研的效率和及时性!对于人类的RefSeq而言,每条RefSeq后面都会有一个COMMENT,COMMENT会显示这条RefSeq的状态。 主要有这些状态:MODEL(说明是自动被NCBI提供的,没有被审核过),INFERRED(由序列分析预测得到,没有经过实验验证),PREDICTED(没有经过人工审核),PROVISIONAL,REVIEWED(已被人工审核),VALIDATED(已经过初步审查,但还没有过最后审查)以及WGS。所以我们在用RefSeq的序列时也要注意看看它的Status哟,看它是否是经过审核的! 了解完RefSeq之后,我们也来看看其它著名的核酸序列数据库吧! (六) NCBI核酸序列数据库-GenBank谈到核酸序列数据库,就不得不提NCBI的GenBank了 GenBank是由美国国立生物技术信息中心(NCBI)维护的一级核酸序列数据库。GenBank数据库中也包括部分蛋白质序列,源于核酸序列注释结果。数据每天更新,每年发行六版release 。GenBank,EMBL和DDBJ同时组成了国际核苷酸序列数据库联盟,让核酸的序列信息得以共享,三大数据库的数据资源都是每天进行更新和交换。 GenBank的数据来源渠道主要有三种: 科研工作者提交的序列数据 2.与其他数据机构协作交换的数据 3.其他从测序中心获得的高通量数据。 再来看一组数字 GenBank的数据来源于260,000多个物种GenBank中约有13%的序列来自于人类数据量排名第一的物种是Homo sapiens(人类),其次是小鼠 目前GenBank的数据已经发布到第227版本(截至2018年8月) 可见我们的科研工作者对人类方面的研究是非常多的!所以数据很多。 GenBank中既然有这么多数据,如果我们想在GenBank中进行序列检索,应该怎么做呢? 可以有两种方式在GenBank中进行检索:(1)泛式检索:例如直接输入感兴趣序列所在基因的名称或者提交作者姓名等(2)特殊标识符检索:即GI号和Genbank的Accession number。 第一种检索方式非常简单,这里就不再赘述。需要我们谈谈的是,第二种检索方式中的GI号和Accession number(注册号/登陆号)是什么含义。 GI number: GI号(GenInfo Identifier,有时用小写字母“gi”表示)是核苷酸序列的序列标识号,由一系列简单的数字组成。它们被连续分配给NCBI处理的每个序列记录,如果一个序列以任何方式改变,那么一个新的GI号将被分配。需要注意的是,GI号和序列的Accession number没有什么关联。 GenBank-Accession Number:Accession Number又叫做注册号/登录号,像GI号一样,它也是唯一的序列标识符。但是与GI号不同的是,AC号一旦分配就不会改变了。一个AC号通常是字母和数字的组合,例如一个字母后跟5位数(如U12345)或两个字母后跟6位数(如AF123456)。 好啦,所以GI号和Accession number都是GenBank数据库中对某条序列进行标识的标识符。这里呢,还需要注意两个概念,那就是GI号和Accession Number.Version.我们的GI号和Accession Number.Version都是可以用来追踪一条序列的演化的。那么这两种标识符之间又有什么关系呢? GI号和Accession Number.Version NCBI的GI号和Accesion Number.Version是两种不同系统的标识符,它们是平行使用的。当序列的数据改变或升级时,将会分配一个新的GI number。Accession number主体编号不会改变,但是它所对应的版本(Accession number.Version)会随着增加。 如NM_008261.1–&gt;NM_008261.2(GI number:6680238–&gt;46575915)。 此外,关于GI号的使用,还有一段不得不说的历史。。。来看看吧: GI(GenInfo Identifier)号是NCBI很早就用来作为序列标识符的编号系统。但是国际核酸序列数据库联盟(GenBank、EMBL和DDBJ)刚成立时并没有统一的使用GI号,而是使用它们各自数据库内部的编号来追踪序列。后来,国际核酸序列数据库联盟(GenBank、EMBL和DDBJ)决定统一使用一个编号来唯一标识序列,于是它们创造了NID(核酸序列标识号)和PID(蛋白质序列标识号)。直到1999年12月,NID和PID的叫法才中断使用,对序列的唯一标识符又恢复成我们现在所熟知的GI号。 同时,1992年的时候国际核苷酸序列数据库联盟(GenBank、EMBL和DDBJ)开始启用Accession Number.Version系统,确保了国际的通用性,并且对序列的标识性与追踪性更加地方便,Accession Number.Version与GI number平行运行。 想了解更多详细的GI历史以及GI和Accession number.version的区别可见:https://www.ncbi.nlm.nih.gov/genbank/sequenceids/ 好啦,到此为止,我们就学习完GenBank数据库了。学完核酸序列数据库之后,下面,我们再来谈谈蛋白质序列数据库-Uniprot。 (七) 蛋白质序列数据库-Uniprot UniProt是Universal Protein 的英文缩写,是一级蛋白质序列数据库。Uniprot整合了三大数据库(Swiss-Prot,TrEMBL和PIR-PSD)的数据,是目前国际上最广泛使用的蛋白质数据库(没有之一)。 大多数情况,我们检索蛋白质序列信息,都是去的UniprotKB,所以掌握UniprotKB的搜索技巧就很重要啦! 了解一下UniprotKB Uniprot中的UniprotKB(UniProt Knowledgebase)是收集蛋白质功能信息的中心枢纽,具有准确,一致,丰富的注释。UniprotKB主要由两部分组成: UniProtKB/Swiss-Prot (包含检查过的、手工注释的条目) UniProtKB/TrEMBL (包含未校验的、自动注释的条目) 由于UniProtKB/TrEMBL中的条目是由计算机自动注释的,所以我们可以看到UniProtKB/TrEMBL的数据数量远远超过了UniProtKB/Swiss-Prot中的数据数量。 了解完基础背景知识之后,我们来看看UniprotKB中的编号ID是什么样的吧 UniprotKB中主要有两种编号系统:Accession number和Entry name 。由于UniprotKB包括了Swiss-Prot(人工注释)和TrEMBL(计算机注释),所以entry name有两种命名方式:UniprotKB/Swiss-Prot entry name和UniprotKB/TrEMBL entry names 。UniprotKB/Swiss-Prot entry nameUniProt 中录入的数据都被分配了一个唯一的 Entry name。UniprotKB/Swiss-Prot Entry name可以由多达11个的大写字母+数字组成。它的命名方式可以表示为X_Y的形式。X是蛋白质或基因名称的缩写(并不是标准的Gene name),最多可以由五个字符组成。“_”表示下划线。Y代表物种的编码,最多也是只能由五个字符组成(通常由属名的前三个字母和种名的前两个字母组成)。例如:PURQ_ZYMMOINS_HUMAN UniprotKB/TrEMBL entry namesUniProtKB/TrEMBL的Entry name 由多达16个大写字母数字字符组成,其命名形式类似于UniProtKB/Swiss-Prot,也是X_Y的形式。其中,X与登录号(Accession number)相同,由6或10个字母数字字符组成。“_”代表下划线。Y代表物种的编码,最多也是只能由五个字符组成。因为TrEMBL中的蛋白质数据太多,不可能所有的条目都人工进行物种编码。所以TrEMBL启用了“虚拟编码”来对物种进行分类。这些虚拟的物种编码都是以数字9为前缀,举例来说,如下: Mnemomnic code Taxonomic identifier Scope 9BACT 2 Bacteria 9CNID 6073 Cnidaria 9FUNG 4751 Fungi 9REOV 10880 Reoviridae Accession NumberUniprotKB中的每个条目都会分配一个唯一的Accession Number。accession number不会随数据的更新而变化,只有数据被删除的时候,accession number才会被删除。所以它是非常稳定的标识符,相当于数据库中的主键。 Uniprot的登录号(accession number)由6个或者10个字母数字的组合构成。构成方式是: [OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z]0-9{1,2} 例如:A2BC19, P12345, A0A022YWF9 刚才我们看到了UniprotKB有两种编号系统,那么这两种编号之间有什么关系和区别呢? Entry name与Accession Number的关系和区别提交数据到UniprotKB之后,每个数据都会被分配一个Accession Number(AC号),这个AC号是唯一的。为了减少数据冗余,如果将UniprotKB中的多个数据合并成一个,AC号仍然是保持不变的。Entry name也是每个数据唯一具有的标识符,它可以展示数据的生物学信息。但是Entry name并不是稳定存在的,比如说我们要将TrEMBL中的数据转入Swiss-Prot,那么我们需要变更数据的Entry name,此时同一个数据的Entry name就发生了改变,但是它的AC号仍然保持不变。这就是他们之间的区别!还有需要注意的是,一个数据可能有两个或者多个accession number 。原因主要有两个:1)当合并两个或多个数据条目时,保留所有数据条目的登录号。第一个AC编号称为“主要AC编号”,其他编号称为“次要AC编号”。编号排序是按字母数字顺序排列的。2)如果现有数据条目被分割为两个或多个数据条目(“拆分”),新的“主要”登录号将归属于所有分裂的条目,而所有原始登录号将保留为“次要”登录号。例如:P29358 被拆分成 P68250 和 P68251 。P68250 和 P68251的次级登录号均为P29358 。 所以,UniprotKB建议,我们最好使用数据的主登录号作为数据引用的方式(不是Entry name ,也不是二级登录号),因为主登录号是唯一并且稳定存在的数据标识符。 了解完AC号和Entry name之后,以UniProtKB/Swiss-Prot为例,我们来看看一组数字 UniProtKB/Swiss-Prot数据小统计截至2018年9月,UniProtKB/Swiss-Prot中共有558,590个Entry name,可见Entry name数量随时间是迅猛增长的 在UniProtKB/Swiss-Prot的数据中,植物占很大一部分,人类数据也占比很多! 蛋白质序列长度分布在0-500左右,最短的蛋白质序列长度只包含2个氨基酸,最长的蛋白质序列包含35,213个氨基酸 截至2018年9月,UniProtKB/Swiss-Prot 包含 558590条注释条目,UniProtKB/TrEMBL包含126780198条注释条目。 Uniprot确实很厉害!这么多数据,以后我们要是找蛋白质信息,都去Uniprot啦! 数据库和ID介绍到这里,基本就快结束啦,最后,我们再学习学习GEO (八) GEO数据库基因表达数据库(Gene Expression Omnibus,GEO)隶属于美国国立卫生研究院的NCBI。是当今最大、最全面的公共基因表达数据资源。GEO数据库的数据由两部分构成: 用户提交的原始数据: GEO Platform (GPL) GEO Sample (GSM) GEO Series (GSE) 其中,GSE = GPL(Platform) + GSA(Sample) GEO数据库整理后的数据:Data set ,Profile 面我们简单介绍一下GPL,GSM和GSE GEO Platform(GPL): 平台数据包含阵列或序列以及阵列平台的简要描述。每个平台都分配了一个特有的登录号用于检索(格式是:GPL+数字编号),例如:平台GPL341https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GPL341 GEO Sample (GSM) : 样本数据描述了每个样本的操作环境,处理方法和分离出的各个成分的丰度测量。每个样本都分配了一个特有的登录号用于检索(格式是:GSM+数字编号)例如:样本GSM12793https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM12793 GEO Series (GSE) : GSE=GPL(Platform)+GSA(Sample) 系列数据将一系列相关的样本联系起来,提供了整个研究的关注点和描述,也包含了描述提取数据、简要结论和分析的表格。每个系列都分配了一个特有的登录号用于检索(格式是:GSE+数字编号)例如:系列GSE830https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE830 看到这里,我们对主流生信数据库的ID规则和数据库的基本情况也就有所了解啦,之后想要进阶还需要不断学习和努力。关于ID转换的部分本文没有讲述,其实这也是一个大坑,等未来再继续填坑! 拓展阅读-GENCODE计划什么是GENCODE计划呢,我们首先来看一段历史 2003年9月,美国国家人类基因组研究所(NHGRI)发起了一个名为ENCODE((DNA元件百科全书))的公共研究计划。项目的目标是识别人类基因组序列中的所有功能元件。GENCODE计划属于ENCODE计划的衍生品,由Sanger研究所进行维护。2003年的时候GENCODE获得了第一批资助,当时GENCODE的目标是对人类基因组中的功能元件进行注释。GENCODE小组在2013年时获得了第二次资助,以继续他们的人类基因组注释工作,并将GENCODE扩展到包括小鼠基因组注释。2017年的时候GENCODE又获得了一批资助,用以完成小鼠基因和人类基因组功能元件的注释工作。 所以GENCODE计划目前的主要工作就是对人类和小鼠的基因组进行功能元件注释。 上文介绍Ensembl的时候也提到过,GENCODE的注释和Ensembl注释的关系是:GENCODE注释来源于havana团队人工完成的基因注释和Ensembl计算机自动完成的基因注释的合并。所以我们查看gtf文件的时候,会发现有“HAVANA”和”ENSEMBL”这两个名称交替出现。HAVANA表示注释来自于人工。ENSEMBL表示注释来源于计算机程序的自动注释。 从GENCODE提供的信息来看,人类一共有58721个基因(包括假基因),目前大概有19940个蛋白质编码基因,16066个长非编码RNA的基因,等等。? GENCODE中,小鼠一共有54446,其中有21969个蛋白质编码基因(比人类多),12840个长非编码RNA的基因,等等。 GENCODE的注释文件的发行版本和Ensembl是一致的,目前GENCODE中的人类gtf注释已经发布到version 29了,小鼠是发布到version 19版本了 更多想要了解的,可以点击:https://www.gencodegenes.org/ 原文链接https://cloud.tencent.com/developer/article/1358527","tags":[{"name":"Database","slug":"Database","permalink":"https://liangbilin.github.io/tags/Database/"},{"name":"组学分析","slug":"组学分析","permalink":"https://liangbilin.github.io/tags/%E7%BB%84%E5%AD%A6%E5%88%86%E6%9E%90/"}]},{"title":"JS中的值类型","date":"2019-12-30T02:28:01.000Z","path":"2019/12/30/Barney--JS中的值类型/","text":"值类型每个编程语言都需要变量，而变量都会有类型。在JS中，主要有两种类型：Primitive Value(aka: 基本类型)和Object(aka: 引用类型)。基本类型主要有：string、number、boolean、undefined、null、symbol(ES6新增基本数据类型)。而引用类型主要有：Date、Array、Function、RegEpx等等。 基本类型和引用类型的区别基本类型和引用类型的最大区别在于：基本类型存储的就是该变量在内存中的值，而引用类型存储的是指向内存中存储值的内存的地址。考虑如下代码： 123456789101112131415161718// example_1.jslet prmValue_1 = 1;let obj_1 = &#123; name: 'Barney', age: 24&#125;;let prmValue_2 = prmValue_1;let obj_2 = obj_1;prmValue_1 = 2;obj_1 = &#123; name: 'Billy', age: 25&#125;;console.log(prmValue_2); // 1console.log(obj_2.name, obj_2.age); // Billy 25 同样是在赋值之后，改变赋值对象的原有的值。结果是prmValue_2不受影响，obj_2的值却和重新赋值后的obj_1保持了一致。这就是基本类型和引用类型存储值的方式导致的结果。下面来拆解example_1.js中的代码，来具体解释这段代码的为何会得到这样的结果。 12345let prmValue_1 = 1;let obj_1 = &#123; name: 'Barney', age: 24&#125;; 此时他们在内存中的关系如下图所示： 接着，执行以下代码： 12let prmValue_2 = prmValue_1;let obj_2 = obj_1; 此时，内存中表示如下图所示： 可以看到，prmValue_1和prmValue_2分别存放了两个基本类型，值为1。而obj_1和obj_2都存放的是同一个内存块的地址的引用。再接着执行下面的代码： 12345prmValue_1 = 2;obj_1 = &#123; name: 'Billy', age: 25&#125;; 此时，各个变量在内存中的表示如下图所示： 如图所示，此时的prmValue_1存放的值是2，而obj_1存放的地址引用则指向了另一个内存块。而obj_2的地址引用与obj_1指向的是同一个地址。所以，当obj_1的内存地址指向变化的时候，obj_2也会跟着一起变化。从而得到了上面的结果。 这就是基本类型与引用类型在赋值的时候，内存变化的全过程了。 类型判断基本类型的判断可以用typeof去判断值类型，但是引用类型用typeof得到结果大部分的都是object,当然也有例外，比如Function。 1234567891011// example_2.jstypeof 1; // numbertypeof '1'; // stringtypeof true; // booleantypeof undefined; // undefinedtypeof Symbol(); // symboltypeof null; // object 有坑，判断null的时候得出的结论是引用类型typeof &#123;&#125;; // objecttypeof []; // objecttypeof function func() &#123;&#125;; // function 又一个坑，typeof判断function的时候，得到的结果是function，虽然function其实本身也是一种引用类型 所以，可以看到。用typeof去判断除null以外的基本类型和function可以得知值的具体类型，但是其他就不行了。那么其他怎么去判断呢？ 答案是Object.prototype.toString()方法。类型判断结果如下： 1234567891011121314// example_3.jsObject.prototype.toString.call(''); // [object String]Object.prototype.toString.call(1); // [object Number]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(newFunction()); // [object Function]Object.prototype.toString.call(newDate()); // [object Date]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call(newRegExp()); // [object RegExp]Object.prototype.toString.call(newError()); // [object Error]Object.prototype.toString.call(document); // [object HTMLDocument]Object.prototype.toString.call(window); //[object global] window 是全局对象 global 的引用 这样得到的结果值准确的，但是在可读性和代码复用上很不好。所以，可以全局建一个公共的judge/index.js的文件，然后分别判断每个类型： 12345678910// judge/index.jsexport function isString (param) &#123; return Object.prototype.toString.call(param) === \"[object String]\"&#125;export function isNull (param) &#123; return Object.prototype.toString.call(param) === \"[object Null]\";&#125;... 强制类型转换在ES5以前，强制类型转换是一个很令人苦恼的问题，因为==、&gt;=、&lt;=、&lt;、&gt;等操作符会把左右两边不是同一个类型的值强制转换成同一个类型，然后去做比较。即隐式强制类型转换。比如 12313 == '13'; // true10 + '1' &lt;= '9'; // true 因为10 + 1 =&gt; '101', '101' &lt; '9' 是这么字符串中的顺序比较ASCII值。而1的ASCII小于9，所以'101' &lt; '9'的结果是true。true == 1; // true 因为这一系列的隐式强制类型转换，可能会导致我们意想不到的结果，所以ES6引入了===操作符，===不会在比较左右两边的值的时候，将两边的值类型强制转换成同一个类型。因为===是比较value &amp;&amp; type的。隐式强制类型转换有很多坑，可以单开，这里先埋坑。 除了隐式强制类型转换，还有显示强制类型转换，强制类型转换是我们主动去调用一些方法，将一个值类型转换成我们预期的值类型的方法，这种方法是可控的，所以，相较于隐式强制类型转换来说，显示强制类型转换安全的多。 1234567891011// 显示强制类型转换Boolean(''); // falseBoolean(null); //falseBoolean(undefined); // falseString(1); // '1'String(null); // 'null'String(undefined); // 'undefined'Number('1'); // 1Number(undefined); // 'NaN'Number(null); // 0Number('string'); // 'NaN' 可以看到，强制类型转换只存在于基本类型之间的转换，不要在非基本类型之间做强制类型转换，因为结果不可控。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liangbilin.github.io/tags/JavaScript/"}]},{"title":"NCBI三种常见数据库--NR/NT、Taxonomy、RefSeq","date":"2019-12-10T16:00:00.000Z","path":"2019/12/11/Billy--NCBI三种常见数据库/","text":"NR/NT 数据库NR(Non-Redundant Protein Sequence Database)非冗余蛋白库,所有GenBank+EMBL+DDBJ+PDB中的非冗余蛋白序列,对于所有已知的或可能的编码序列,NR记录中都给出了相应的氨基酸序列(通过已知或可能的读码框推断而来)以及专门蛋白数据库中的序列号。NR库相当于一个以核酸序列为基础的交叉索引,将核酸数据和蛋白数据联系起来。 NT(Nucleotide Sequence Database),核酸序列数据库,是NR库的子集。 NR和NT库都可以通过NCBI(National Center for Biotechnology Information,美国国立生物技术信息中心)进行在线BLAST,也可以在ftp://ftp.ncbi.nih.gov/blast/db地址中将数据直接下载下来,需要注意的是,NR和NT库是被切分为以数字命名的子数据库上传的,将所有的子数据库放到同一个目录下,解压缩后构建索引文件即可。 Taxonomy 数据库NCBI的分类数据库,包括大于7万余个物种的名字和种系,这些物种都至少在遗传数据库中有一条核酸或蛋白序列。其目的是为序列数据库建立一个一致的种系发生分类学。 https://ftp.ncbi.nih.gov/pub/taxonomy下载gi_taxid.nucl.dmp.gz(NT记录ID号与taxid对应关系),gi_taxid.prot.dmp.gz(NR记录ID号与taxid对应关系)和taxdump.tar.gz三个文件。 taxdump.tar.gz里包含两个重要文件,即names.dmp和nodes.dmp。 &lt;1&gt; names.dmp文件共包含4列,以“|”分割,如图1。各列描述,如图2。 图1:names.dmp 图2:各列描述,其中tax_id即为taxonomy的记录号,name_txt即对应tax_id号的物种名称。 &lt;2&gt; nodes.dmp文件共包含13列,以“|”分割,各列描述如下: 图3:其中,物种分类注释时需要tax_id(Taxonomy记录号),parent tax_id(上一层分类级别的tax_id)和rank(该tax_id所处的分类层级)。 RefSeq 数据库RefSeq,the reference sequence database,即参考序列数据库,包含RefSeq_genomic(NCBI genomic reference sequences),RefSeq_protein(NCBI protein reference sequences)和RefSeq transpans(NCBI transpans reference sequences)。 具有生物意义上的非冗余基因,转录本和蛋白质序列,是经过NCBI和其他组织校正的数据库,使用人类基因命名委员会定义的术语,并且包括了官方的基因符号和可选的符号。RefSeq记录有三种可以获得的状态:预测的、临时的和检查过的(reviewd)。预测的RefSeq记录是来自于那些未知功能的cDNA序列,它们有一个预测的蛋白编码区;临时的RefSeq记录还没有被检查过,它们是有自动的程序产生的;检查过的记录代表了目前关于一个基因和它的转录子的知识的汇编,它们很多都来自于GenBank记录、人类基因组命名委员会和OMIM,RefSeq标准为人类基因组的功能注解提供一个基础。 RefSeq数据库和GenBank数据库的区别在于:GenBank是一个开放的数据库,对每个基因都含有许多序列。很多研究者或者公司都可以自己提交序列,另外这个数据库每天都要和EMBL和DDBJ交换数据。genbank的数据可能重复或者不准。而RefSeq数据库被设计成每个人类位点挑出一个代表序列来减少重复,是NCBI提供的校正的序列数据和相关的信息。数据库包括构建的基因组contig、mRNA、蛋白和整个染色体。refseq序列是NCBI筛选过的非冗余数据库,一般可信度比较高。","tags":[{"name":"Database","slug":"Database","permalink":"https://liangbilin.github.io/tags/Database/"}]},{"title":"表观组染色体开放区域分析:ATAC-seq","date":"2019-11-30T16:00:00.000Z","path":"2019/12/01/Billy--表观组染色体开放区域分析—ATAC-seq/","text":"DNA的高维空间结构人类细胞DNA完全展开约有2米长,那么细胞是如何将这些DNA装入直径仅为5微米大小的细胞核的呢?细胞会将DNA进行不同层次的折叠压缩形成可以调控的结构。具体而言,DNA先缠绕在组蛋白形成核小体结构;然后6个核小体形成一个环,组成螺线管;螺线管进一步折叠成超螺线管;超螺线管再缠绕形成染色体。 当某个基因需要表达的时候,涉及到的区域就会从压缩的高级结构解开。这部分打开的区域就叫做开放染色质(open chromatin),一些调控蛋白如转录因子或辅因子就能够与之结合,染色质的这种特性就被称为可进入性(chromatin accessibility)。 开放染色质区域鉴定方法1. 传统实验方法:MNase-seq 和 DNase I hypersensitivity assay这两个实验的主要思路是一致的:染色质变得开放,就意味着DNA和组蛋白的浓聚程度降低,就会有一部分DNA暴露出来。而一旦失去了蛋白质的保护,这部分DNA就可以被DNA酶(MNase或DNase I)切割。再把切割出来的DNA进行测序并比对到参考基因组,就能知道开放染色质的区域。但是这两个方法的重复性很差且耗时费力。 2. DNA转座酶结合高通量测序技术的新方法:ATAC-seq2013年,美国Stanford大学的William Greenleaf教授研发了一种全新的方法,即 Assay for Transposase Accessible Chromatin with high-throughput sequencing (ATAC-seq)。 DNA转座是通过DNA转座酶实现的,把DNA序列从染色体的一个区域搬运到另外一个区域的现象。它也要求相应区域是开放的。那么,如果将携带已知DNA序列标签的转座复合物(即带着测序标签的转座酶)加入到细胞核中,序列标签将插入到基因组上。再利用标签上已知的序列进行PCR扩增和测序,就能够获得开放染色质区域的信息。相比于传统方法,ATAC-seq的重复性和可操作性都更高,而且对细胞量要求也更小,最少500多个细胞即可。 单细胞水平ATAC-seq目前大部分研究是在群体细胞水平中探索表观遗传的平均特征,但极其复杂和富有异质性的组织则要求分辨率更高的单细胞表观遗传学研究技术。2015年, William Greenleaf 团队将 ATAC-seq 方法与 Fluidigm 的单细胞平台C1整合,利用微流控芯片完成捕获、裂解、转座、PCR等实验过程,建立了自动化的单细胞染色质可接近性图谱研究方法 Single-cell ATAC-seq (scATAC-seq)。 ATAC技术获得染色质开放区域信息主要依赖于Tn5转座酶,这是一种随机切割DNA的酶。其原理是核小体连接致密的地方,转座酶不能进入,而染色质开放的区域,转座酶能够进入并切割暴露的DNA,同时连接上特异性的序列。因此,只要将携带已知DNA序列标签的转座酶加入到细胞核中,再利用已知序列的标签进行PCR后测序,就可获得基因组染色质开放程度的信息。 参考资料 https://www.360zhyx.com/home-research-index-rid-64254.shtml http://www.ebiotrade.com/newsf/2019-2/2019221172502887.htm","tags":[{"name":"二代测序","slug":"二代测序","permalink":"https://liangbilin.github.io/tags/%E4%BA%8C%E4%BB%A3%E6%B5%8B%E5%BA%8F/"},{"name":"表观组","slug":"表观组","permalink":"https://liangbilin.github.io/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/"}]},{"title":"GATK4：germline SNP calling","date":"2019-11-30T16:00:00.000Z","path":"2019/12/01/Billy--GATK4—germline SNP calling/","text":"1. 简介单核苷酸多态性(single nucleotide polymorphism，SNP),主要是指在基因组水平上由单个核苷酸的变异所引起的DNA序列多态性。从来源上看，SNP可以分为 “germline SNP” 和 “somatic SNP”。 如下图所示，Germline的mutation其实来自于上一代，这种mutation会随着个体整个胚胎发育过程存在。在研究方法上，Germline的mutation在家系分析中占有重要角色，对很多遗传病（其中包括遗传型肿瘤）的研究中占有重要地位。在测序过程中，除了个体测序之外，还会加上个体的家属一同测序。病理分析时也会考虑家族背景的影响。 somatic突变是不遗传的，在研究方法上主要偏重采集癌症组织和正常组织进行比较得到结果。因此，在call somatic mutation的时候最好有同一个体的正常组织进行参照。从研究意义来讲，somatic更侧重于单个患者的癌症分型和发病机理研究。 2. GATK4下载安装在GATK的官方网站下载目前最新版本4.1.2.0。并将软件压缩文件上传至Linux服务器系统上。解压缩即可使用大部分功能，但涉及到germline CNV calling的数据分析则需要安装相应的python环境。 3. 准备相关数据：所有准备的数据都保存在一个index的文件目录下3.1 下载相关数据这里以分析人类的数据作为案例。选择的参考基因组为hg38，相应的数据由broadinstitute提供： 1lftp ftp.broadinstitute.org&#x2F;bundle -u gsapubftp-anonymous #没有密码 进入该ftp后至少需要下载如下的数据： Homo_sapiens_assembly38.fasta.gz 1000G_phase1.snps.high_confidence.hg38.vcf.gz 1000G_phase1.snps.high_confidence.hg38.vcf.gz.tbi dbsnp_146.hg38.vcf.gz dbsnp_146.hg38.vcf.gz.tbi Mills_and_1000G_gold_standard.indels.hg38.vcf.gz Mills_and_1000G_gold_standard.indels.hg38.vcf.gz.tbi 3.2 建立索引文件 通过BWA软件，为参考基因组hg38建立索引文件：1bwa index hg38.fa 通过samtools软件，为参考基因组 hg38 建立fai索引文件:1samtools faidx hg38.fa 4. 数据分析流程4.1 质控 通过FastQC软件检测二代测序原始数据，如果数据已经是被清理过的干净数据，则可以直接进行比对。 如果数据不是干净的数据，则需要进行数据清理步骤，即使用Trimmomatic等软件进行数据清理。 通过质控获得的是一个比较干净的测序原始数据(cleandata.fq)。 4.2 比对 通过软件BWA将干净的测序数据比对到参考基因组上： 1bwa mem -t 15 -M -R &quot;@RG\\tID:G118bloodEX\\tSM:G118bloodEX\\tLB:WES\\tPL:Illumina&quot; &#x2F;GPFS&#x2F;liangbilin&#x2F;WES&#x2F;index&#x2F;Homo_sapiens.GRCh38.dna.chromosome.fa G118bloodEX_1.fastq G118bloodEX_2.fastq 1&gt; ..&#x2F;aln&#x2F;G118bloodEX.sam 2&gt; ..&#x2F;aln&#x2F;G118bloodEX.log -t 设置软件线程数-M 用来处理同一个reads比对到参考基因组上不同位置的情况。官方解释为：mark shorter split hits as secondary. 设置该参数的目的是为了兼容GATK的markDuplicates模块。-R 接的是 Read Group的字符串信息，它是用来将比对的read进行分组的，这个信息对于我们后续分析非常重要。具体分析时候需要修改该参数的信息。 把sam格式转为bam格式 1samtools view -bS G118bloodEX.sam &gt; G118bloodEX.bam 对bam文件进行排序 1samtools sort -@ 20 G118bloodEX.bam -o G118bloodEX.sorted.bam 4.3 标记重复在NGS测序之前都需要先构建测序文库：通过物理（超声）打断或者化学试剂（酶切）切断原始的DNA序列，然后选择特定长度范围的序列去进行PCR扩增并上机测序。这个过程中产生的重复reads，增大了变异检测结果的假阴率和假阳率: PCR反应过程中也会带来新的碱基错误。发生在前几轮的PCR扩增发生的错误会在后续的PCR过程中扩大，同样带来假的变异； PCR反应可能会对包含某一个碱基的DNA模版扩增更加剧烈（这个现象称为PCR Bias）; 如果某个变异位点的变异碱基都是来自于PCR重复，而我们却认为它深度足够判断是真的变异位点，这个结论其实有很大可能是假阳性。 通过GATK4的MarkDuplicates标记重复： 1gatk MarkDuplicates -I G118bloodEX.sorted.bam -O G118bloodEX.sorted.marked.bam -M G118bloodEX.metrics 4.4 矫正bam文件检测并矫正双端测序的mate信息。如果上一步骤只是标记重复而不是删除，理论上不需要进行该步骤。 1gatk FixMateInformation -I G118bloodEX.sorted.marked.bam -O G118bloodEX.sorted.marked.fixed.bam -SO coordinate 4.5 为bam文件生成索引1samtools index G118bloodEX.sorted.marked.fixed.bam 4.6 调整碱基测序质量值变异检测是一个极度依赖测序碱基质量值，因为这个质量值是衡量我们测序出来的这个碱基到底有多正确的重要指标。对base的quality score进行校正）碱基质量分数重校准（Base quality score recalibration，BQSR)，就是利用机器学习的方式调整原始碱基的质量分数。它分为两个步骤: 利用已有的snp数据库，建立相关性模型，产生重校准表 1gatk BaseRecalibrator -R &#x2F;GPFS&#x2F;liangbilin&#x2F;biomarker&#x2F;index&#x2F;Homo_sapiens_assembly38.fa -I G118bloodEX.sorted.marked.fixed.bam --known-sites &#x2F;GPFS&#x2F;liangbilin&#x2F;biomarker&#x2F;index&#x2F;dbsnp_146.hg38.vcf.gz --known-sites &#x2F;GPFS&#x2F;liangbilin&#x2F;biomarker&#x2F;index&#x2F;Mills_and_1000G_gold_standard.indels.hg38.vcf.gz -O G118bloodEX.recal.table -R 参考基因组-I 输入的bam文件–known-sites 已知的变异位点文件，同时需要已经创建索引文件-O 输出重校准表 根据这个模型对原始碱基进行调整，只会调整非已知SNP区域。 1gatk ApplyBQSR -R &#x2F;GPFS&#x2F;liangbilin&#x2F;biomarker&#x2F;index&#x2F;Homo_sapiens_assembly38.fa -I G118bloodEX.sorted.marked.fixed.bam -bqsr G118bloodEX.recal.table -O G118bloodEX.sorted.marked.fixed.bqsr.bam 4.7 变异检测前确定bam文件是否符合GATK要求 (选做)运行GATK4的 ValidateSamFile 模块，如果显示 No Error，则可以用HaplotypeCaller call SNP/Indel。 1~&#x2F;program&#x2F;gatk-4.1.2.0&#x2F;gatk ValidateSamFile -I G118bloodEX.sorted.marked.fixed.bqsr.bam &gt;&gt;G118bloodEX.ValidateSamFile.log 2&gt;&amp;1 4.8 Call candidate variants对于做 germline 情况，利用 HaplotypeCaller 检测突变。HaplotypeCaller的应用有两种做法，区别在于是否生成中间文件gVCF： 直接进行HaplotypeCaller，这适合于单样本，只执行一次HaplotypeCaller。 1gatk HaplotypeCaller -R &#x2F;GPFS&#x2F;liangbilin&#x2F;biomarker&#x2F;index&#x2F;Homo_sapiens_assembly38.fa -I G118bloodEX.sorted.marked.fixed.bqsr.bam -D ..&#x2F;index&#x2F;dbsnp_146.hg38.vcf.gz -A QualByDepth -A RMSMappingQuality -A MappingQualityRankSumTest -A ReadPosRankSumTest -A FisherStrand -A StrandOddsRatio -A Coverage -O G118bloodEX.vcf -I 准备好的BAM文件，可以提交多个( -I 1.bam -I 2.bam -I 3.bam … ) 如果多样本，每增加一个样本数据都需要重新运行这个HaplotypeCaller，而这个时候算法需要重新去读取所有人的BAM文件，浪费大量时间。每个样本先各自生成gVCF，然后再进行群体joint-genotype。gVCF全称是genome VCF，是每个样本用于变异检测的中间文件，格式类似于VCF，它把joint-genotype过程中所需的所有信息都记录在这里面，文件无论是大小还是数据量都远远小于原来的BAM文件。这样一旦新增加样本也不需要再重新去读取所有人的BAM文件了，只需为新样本生成一份gVCF，然后重新执行这个joint-genotype就行了。 12","tags":[{"name":"二代测序","slug":"二代测序","permalink":"https://liangbilin.github.io/tags/%E4%BA%8C%E4%BB%A3%E6%B5%8B%E5%BA%8F/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"samtools常用命令详解(转载)","date":"2019-11-15T16:00:00.000Z","path":"2019/11/16/Billy--软件samtools教程（转载）/","text":"1. Viewview命令的主要功能是:将sam文件转换成bam文件;然后对bam文件进行各种操作,比如数据的排序(不属于本命令的功能)和提取(这些操作 是对bam文件进行的,因而当输入为sam文件的时候,不能进行该操作);最后将排序或提取得到的数据输出为bam或sam(默认的)格式。 bam文件优点:bam文件为二进制文件,占用的磁盘空间比sam文本文件小;利用bam二进制文件的运算速度快。 view命令中,对sam文件头部的输入(-t或-T)和输出(-h)是单独的一些参数来控制的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Usage: samtools view [options] &lt;in.bam&gt;|&lt;in.sam&gt; [region1 [...]]默认情况下不加 region,则是输出所有的 region.Options: -b output BAM默认下输出是 SAM 格式文件,该参数设置输出 BAM 格式-h print header for the SAM output默认下输出的 sam 格式文件不带 header,该参数设定输出sam文件时带 header 信息-H print header only (no alignments)-S input is SAM默认下输入是 BAM 文件,若是输入是 SAM 文件,则最好加该参数,否则有时候会报错。-u uncompressed BAM output (force -b)该参数的使用需要有-b参数,能节约时间,但是需要更多磁盘空间。-c Instead of printing the alignments, only count them and print thetotal number. All filter options, such as ‘-f’, ‘-F’ and ‘-q’ ,are taken into account.-1 fast compression (force -b)-x output FLAG in HEX (samtools-C specific)-X output FLAG in string (samtools-C specific)-c print only the count of matching records-L FILE output alignments overlapping the input BED FILE [null]-t FILE list of reference names and lengths (force -S) [null]使用一个list文件来作为header的输入-T FILE reference sequence file (force -S) [null]使用序列fasta文件作为header的输入-o FILE output file name [stdout]-R FILE list of read groups to be outputted [null]-f INT required flag, 0 for unset [0]-F INT filtering flag, 0 for unset [0]Skip alignments with bits present in INT [0]数字4代表该序列没有比对到参考序列上数字8代表该序列的mate序列没有比对到参考序列上-q INT minimum mapping quality [0]-l STR only output reads in library STR [null]-r STR only output reads in read group STR [null]-s FLOAT fraction of templates to subsample; integer part as seed [-1]-? longer help 例子 12345678910111213141516171819202122232425262728293031将sam文件转换成bam文件$ samtools view -bS abc.sam &gt; abc.bam$ samtools view -b -S abc.sam -o abc.bam提取比对到参考序列上的比对结果$ samtools view -bF 4 abc.bam &gt; abc.F.bam提取paired reads中两条reads都比对到参考序列上的比对结果,只需要把两个4+8的值12作为过滤参数即可$ samtools view -bF 12 abc.bam &gt; abc.F12.bam提取没有比对到参考序列上的比对结果$ samtools view -bf 4 abc.bam &gt; abc.f.bam提取bam文件中比对到caffold1上的比对结果,并保存到sam文件格式$ samtools view abc.bam scaffold1 &gt; scaffold1.sam提取scaffold1上能比对到30k到100k区域的比对结果$ samtools view abc.bam scaffold1:30000-100000 $gt; scaffold1_30k-100k.sam根据fasta文件,将 header 加入到 sam 或 bam 文件中$ samtools view -T genome.fasta -h scaffold1.sam &gt; scaffold1.h.sam 2. Sortsort对bam文件进行排序。 123Usage: samtools sort [-n] [-m &lt;maxMem&gt;] &lt;in.bam&gt; &lt;out.prefix&gt; -m 参数默认下是 500,000,000 即500M(不支持K,M,G等缩写)。对于处理大数据时,如果内存够用,则设置大点的值,以节约时间。-n 设定排序方式按short reads的ID排序。默认下是按序列在fasta文件中的顺序(即header)和序列从左往右的位点排序。 例子: 12$ samtools sort abc.bam abc.sort ###注意 abc.sort 是输出文件的前缀,实际输出是 abc.sort.bam$ samtools view abc.sort.bam | less -S 3. Merge将2个或2个以上的已经sort了的bam文件融合成一个bam文件。融合后的文件不需要则是已经sort过了的。 123456789101112131415161718192021Usage: samtools merge [-nr] [-h inh.sam] &lt;out.bam&gt; &lt;in1.bam&gt; &lt;in2.bam&gt;[...]Options: -n sort by read names-r attach RG tag (inferred from file names)-u uncompressed BAM output-f overwrite the output BAM if exist-1 compress level 1-R STR merge file in the specified region STR [all]-h FILE copy the header in FILE to &lt;out.bam&gt; [in1.bam]Note: Samtools&#39; merge does not reconstruct the @RG dictionary in the header. Usersmust provide the correct header with -h, or uses Picard which properly maintainsthe header dictionary in merging. 4. index必须对bam文件进行默认情况下的排序后,才能进行index。否则会报错。 建立索引后将产生后缀为.bai的文件,用于快速的随机处理。很多情况下需要有bai文件的存在,特别是显示序列比对情况下。比如samtool的tview命令就需要;gbrowse2显示reads的比对图形的时候也需要。 1Usage: samtools index &lt;in.bam&gt; [out.index] 例子 123以下两种命令结果一样$ samtools index abc.sort.bam$ samtools index abc.sort.bam abc.sort.bam.bai 5. faidx对fasta文件建立索引,生成的索引文件以.fai后缀结尾。该命令也能依据索引文件快速提取fasta文件中的某一条(子)序列。 1234567891011121314151617Usage: samtools faidx &lt;in.bam&gt; [ [...]]对基因组文件建立索引$ samtools faidx genome.fasta生成了索引文件genome.fasta.fai,是一个文本文件,分成了5列。第一列是子序列的名称;第二列是子序列的长度;个人认为“第三列是序列所在的位置”,因为该数字从上往下逐渐变大,最后的数字是genome.fasta文件的大小;第4和5列不知是啥意思。于是通过此文件,可以定位子序列在fasta文件在磁盘上的存放位置,直接快速调出子序列。由于有索引文件,可以使用以下命令很快从基因组中提取到fasta格式的子序列$ samtools faidx genome.fasta scffold_10 &gt; scaffold_10.fasta 6. tviewtview能直观的显示出reads比对基因组的情况,和基因组浏览器有点类似。 1234567891011121314151617181920Usage: samtools tview &lt;aln.bam&gt; [ref.fasta]当给出参考基因组的时候,会在第一排显示参考基因组的序列,否则,第一排全用N表示。按下 g ,则提示输入要到达基因组的某一个位点。例子“scaffold_10:1000&quot;表示到达第10号scaffold的第1000个碱基位点处。使用H(左)J(上)K(下)L(右)移动显示界面。大写字母移动快,小写字母移动慢。使用空格建向左快速移动(和 L 类似),使用Backspace键向左快速移动(和 H 类似)。Ctrl+H 向左移动1kb碱基距离; Ctrl+L 向右移动1kb碱基距离可以用颜色标注比对质量,碱基质量,核苷酸等。3040的碱基质量或比对质量使用白色表示;2030黄色;1020绿色;010蓝色。使用点号&#39;.&#39;切换显示碱基和点号;使用r切换显示read name等还有很多其它的使用说明,具体按 ? 键来查看。 7. flagstat给出BAM文件的比对结果 123456789101112131415161718192021222324252627282930313233343536373839404142Usage: samtools flagstat &lt;in.bam&gt;$ samtools flagstat example.bam11945742 + 0 in total (QC-passed reads + QC-failed reads)#总共的reads数0 + 0 duplicates7536364 + 0 mapped (63.09%:-nan%)#总体上reads的匹配率11945742 + 0 paired in sequencing#有多少reads是属于paired reads5972871 + 0 read1#reads1中的reads数5972871 + 0 read2#reads2中的reads数6412042 + 0 properly paired (53.68%:-nan%)#完美匹配的reads数:比对到同一条参考序列,并且两条reads之间的距离符合设置的阈值6899708 + 0 with itself and mate mapped#paired reads中两条都比对到参考序列上的reads数636656 + 0 singletons (5.33%:-nan%)#单独一条匹配到参考序列上的reads数,和上一个相加,则是总的匹配上的reads数。469868 + 0 with mate mapped to a different chr#paired reads中两条分别比对到两条不同的参考序列的reads数243047 + 0 with mate mapped to a different chr (mapQ&gt;&#x3D;5) 7. depth12345678Usage: bam2depth [-r reg] [-q baseQthres] [-Q mapQthres] [-b in.bed] &lt;in1.bam&gt; [...]-r 后面跟染色体号(region)注意:做depth之前必须做samtools index;示例:samtools depth in.bam &gt; out.depth.txt注意: in.bam 必须经过了排序。 8. 其他有用命令reheader 替换bam文件的头 1$ samtools reheader &lt;in.header.sam&gt; &lt;in.bam&gt; cat 连接多个bam文件,适用于非sorted的bam文件 1$ samtools cat [-h header.sam] [-o out.bam] &lt;in1.bam&gt; &lt;in2.bam&gt; [ ... ] idxstats 统计一个表格,4列,分别为”序列名,序列长度,比对上的reads数,unmapped reads number”。第4列应该是paired reads中有一端能匹配到该scaffold上,而另外一端不匹配到任何scaffolds上的reads数。 1$ samtools idxstats &lt;aln.bam&gt; 9. 将bam文件转换为fastq文件有时候,我们需要提取出比对到一段参考序列的reads,进行小范围的分析,以利于debug等。这时需要将bam或sam文件转换为fastq格式。该网站提供了一个bam转换为fastq的程序: http://www.hudsonalpha.org/gsl/information/software/bam2fastq 12345$ wget http:&#x2F;&#x2F;www.hudsonalpha.org&#x2F;gsl&#x2F;static&#x2F;software&#x2F;bam2fastq-1.1.0.tgz$ tar zxf bam2fastq-1.1.0.tgz$ cd bam2fastq-1.1.0$ make$ .&#x2F;bam2fastq &lt;in.bam&gt; 10. mpileupsamtools还有个非常重要的命令mpileup,以前为pileup。该命令用于生成bcf文件,再使用bcftools进行SNP和Indel的分析。bcftools是samtool中附带的软件,在samtools的安装文件夹中可以找到。 最常用的参数有2: -f 来输入有索引文件的fasta参考序列; -g 输出到bcf格式。用法和最简单的例子如下 12345678Usage: samtools mpileup [-EBug] [-C capQcoef] [-r reg] [-f in.fa] [-l list] [-M capMapQ] [-Q minBaseQ] [-q minMapQ] in.bam [in2.bam [...]]$ samtools mpileup -f genome.fasta abc.bam &gt; abc.txt$ samtools mpileup -gSDf genome.fasta abc.bam &gt; abc.bcf$ samtools mpileup -guSDf genome.fasta abc.bam | bcftools view -cvNg - &gt; abc.vcf mpileup不使用-u或-g参数时,则不生成二进制的bcf文件,而生成一个文本文件(输出到标准输出)。该文本文件统计了参考序列中每个碱基位点的比对情况;该文件每一行代表了参考序列中某一个碱基位点的比对结果。比如: 12345678910scaffold_1 2841 A 11 ,,,...,.... BHIGDGIJ?FFscaffold_1 2842 C 12 ,$,,...,....^I. CFGEGEGGCFF+scaffold_1 2843 G 11 ,,...,..... FDDDDCD?DD+scaffold_1 2844 G 11 ,,...,..... FA?AAAA&lt;AA+scaffold_1 2845 G 11 ,,...,..... F656666166*scaffold_1 2846 A 11 ,,...,..... (1.1111)11*scaffold_1 2847 A 11 ,,+9acggtgaag.+9ACGGTGAAT.+9ACGGTGAAG.+9ACGGTGAAG,+9acggtgaag.+9ACGGTGAAG.+9ACGGTGAAG.+9ACGGTGAAG.+9ACGGTGAAG.+9ACGGTGAAG %.+....-..)scaffold_1 2848 N 11 agGGGgGGGGG !!$!!!!!!!!scaffold_1 2849 A 11 c$,...,..... !0000000000scaffold_1 2850 A 10 ,...,..... 353333333 mpileup生成的结果包含6行:参考序列名;位置;参考碱基;比对上的reads数;比对情况;比对上的碱基的质量。其中第5列比较复杂,解释如下: 1 ‘.’代表与参考序列正链匹配。2 ‘,’代表与参考序列负链匹配。3 ‘ATCGN’代表在正链上的不匹配。4 ‘atcgn’代表在负链上的不匹配。5 ‘*’代表模糊碱基6 ‘^’代表匹配的碱基是一个read的开始;’^’后面紧跟的ascii码减去33代表比对质量;这两个符号修饰的是后面的碱基,其后紧跟的碱基(.,ATCGatcgNn)代表该read的第一个碱基。7 ‘$’代表一个read的结束,该符号修饰的是其前面的碱基。8 正则式’+[0-9]+[ACGTNacgtn]+’代表在该位点后插入的碱基;比如上例中在scaffold_1的2847后插入了9个长度的碱基acggtgaag。表明此处极可能是indel。9 正则式’-[0-9]+[ACGTNacgtn]+’代表在该位点后缺失的碱基; pileup具体的参数如下: 12345678910111213141516171819202122232425262728293031323334353637输入参数-6 Assume the quality is in the Illumina 1.3+ encoding. -A Do not skip anomalous read pairs in variant calling. -B Disable probabilistic realignment for the computation of base alignment quality (BAQ). BAQ is the Phred-scaled probability of a read base being misaligned. Applying this option greatly helps to reduce false SNPs caused by misalignments. -b FILE List of input BAM files, one file per line [null]-C INT Coefficient for downgrading mapping quality for reads containing excessive mismatches. Given a read with a phred-scaled probability q of being generated from the mapped position, the new mapping quality is about sqrt((INT-q)&#x2F;INT)*INT. A zero value disables this functionality; if enabled, the recommended value for BWA is 50. [0] -d INT At a position, read maximally INT reads per input BAM. [250] -E Extended BAQ computation. This option helps sensitivity especially for MNPs, but may hurt specificity a little bit. -f FILE The faidx-indexed reference file in the FASTA format. The file can be optionally compressed by razip. [null] -l FILE BED or position list file containing a list of regions or sites where pileup or BCF should be generated [null] -M INT cap mapping quality at INT [60]-q INT Minimum mapping quality for an alignment to be used [0] -Q INT Minimum base quality for a base to be considered [13]-r STR Only generate pileup in region STR [all sites] 输出参数-D Output per-sample read depth (require -g&#x2F;-u)-g Compute genotype likelihoods and output them in the binary call format (BCF).-S Output per-sample Phred-scaled strand bias P-value (require -g&#x2F;-u)-u Similar to -g except that the output is uncompressed BCF, which is preferred for piping.Options for Genotype Likelihood Computation (for -g or -u):-e INT Phred-scaled gap extension sequencing error probability. Reducing INT leads to longer indels. [20]-h INT Coefficient for modeling homopolymer errors. Given an l-long homopolymer run, the sequencing error of an indel of size s is modeled as INT*s&#x2F;l. [100]-I Do not perform INDEL calling-L INT Skip INDEL calling if the average per-sample depth is above INT. [250]-o INT Phred-scaled gap open sequencing error probability. Reducing INT leads to more indel calls. [40]-P STR Comma dilimited list of platforms (determined by @RG-PL) from which indel candidates are obtained. It is recommended to collect indel candidates from sequencing technologies that have low indel error rate such as ILLUMINA. [all] 11. 使用bcftoolsbcftools和samtools类似,用于处理vcf(variant call format)文件和bcf(binary call format)文件。前者为文本文件,后者为其二进制文件。 bcftools使用简单,最主要的命令是view命令,其次还有index和cat等命令。index和cat命令和samtools中类似。此处主讲使用view命令来进行SNP和Indel calling。该命令的使用方法和例子为: 12345$ bcftools view [-AbFGNQSucgv] [-D seqDict] [-l listLoci] [-s listSample] [-i gapSNPratio] [-t mutRate] [-p varThres] [-P prior] [-1 nGroup1] [-d minFrac] [-U nPerm] [-X permThres] [-T trioType] in.bcf [region]$ bcftools view -cvNg abc.bcf &gt; snp_indel.vcf 生成的结果文件为vcf格式,有10列,分别是:1 参考序列名;2 varianti所在的left-most位置;3 variant的ID(默认未设置,用’.’表示);4 参考序列的allele;5 variant的allele(有多个alleles,则用’,’分隔);6 variant/reference QUALity;7 FILTers applied;8 variant的信息,使用分号隔开;9 FORMAT of the genotype fields, separated by colon (optional); 10 SAMPLE genotypes and per-sample information (optional)。 例如: 12345678scaffold_1 2847 . A AACGGTGAAG 194 . INDEL;DP&#x3D;11;VDB&#x3D;0.0401;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,8,3;MQ&#x3D;35;FQ&#x3D;-67.5 GT:PL:GQ 1&#x2F;1:235,33,0:63scaffold_1 3908 . G A 111 . DP&#x3D;13;VDB&#x3D;0.0085;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,5,7;MQ&#x3D;42;FQ&#x3D;-63 GT:PL:GQ 1&#x2F;1:144,36,0:69scaffold_1 4500 . A G 31.5 . DP&#x3D;8;VDB&#x3D;0.0034;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,1,3;MQ&#x3D;42;FQ&#x3D;-39 GT:PL:GQ 1&#x2F;1:64,12,0:21scaffold_1 4581 . TGGNGG TGG 145 . INDEL;DP&#x3D;8;VDB&#x3D;0.0308;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,0,8;MQ&#x3D;42;FQ&#x3D;-58.5 GT:PL:GQ 1&#x2F;1:186,24,0:45scaffold_1 4644 . G A 195 . DP&#x3D;21;VDB&#x3D;0.0198;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,10,10;MQ&#x3D;42;FQ&#x3D;-87 GT:PL:GQ 1&#x2F;1:228,60,0:99scaffold_1 4827 . NACAAAGA NA 4.42 . INDEL;DP&#x3D;1;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,1,0;MQ&#x3D;40;FQ&#x3D;-37.5 GT:PL:GQ 0&#x2F;1:40,3,0:3scaffold_1 4854 . A G 48 . DP&#x3D;6;VDB&#x3D;0.0085;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,2,1;MQ&#x3D;41;FQ&#x3D;-36 GT:PL:GQ 1&#x2F;1:80,9,0:16scaffold_1 5120 . A G 85 . DP&#x3D;8;VDB&#x3D;0.0355;AF1&#x3D;1;AC1&#x3D;2;DP4&#x3D;0,0,5,3;MQ&#x3D;42;FQ&#x3D;-51 GT:PL:GQ 1&#x2F;1:118,24,0:45 第8列中显示了对variants的信息描述,比较重要,其中的 Tag 的描述如下: 1234567891011121314Tag Format DescriptionAF1 double Max-likelihood estimate of the site allele frequency (AF) of the first ALT alleleDP int Raw read depth (without quality filtering)DP4 int[4] # high-quality reference forward bases, ref reverse, alternate for and alt rev basesFQ int Consensus quality. Positive: sample genotypes different; negative: otherwiseMQ int Root-Mean-Square mapping quality of covering readsPC2 int[2] Phred probability of AF in group1 samples being larger (,smaller) than in group2PCHI2 double Posterior weighted chi^2 P-value between group1 and group2 samplesPV4 double[4] P-value for strand bias, baseQ bias, mapQ bias and tail distance biasQCHI2 int Phred-scaled PCHI2RP int # permutations yielding a smaller PCHI2CLR int Phred log ratio of genotype likelihoods with and without the trio&#x2F;pair constraintUGT string Most probable genotype configuration without the trio constraintCGT string Most probable configuration with the trio constraint bcftools view 的具体参数如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Input&#x2F;Output Options:-A Retain all possible alternate alleles at variant sites. By default, the view command discards unlikely alleles.-b Output in the BCF format. The default is VCF.-D FILE Sequence dictionary (list of chromosome names) for VCF-&gt;BCF conversion [null]-F Indicate PL is generated by r921 or before (ordering is different).-G Suppress all individual genotype information.-l FILE List of sites at which information are outputted [all sites]-N Skip sites where the REF field is not A&#x2F;C&#x2F;G&#x2F;T-Q Output the QCALL likelihood format-s FILE List of samples to use. The first column in the input gives the sample names and the second gives the ploidy, which can only be 1 or 2. When the 2nd column is absent, the sample ploidy is assumed to be 2. In the output, the ordering of samples will be identical to the one in FILE. [null]-S The input is VCF instead of BCF.-u Uncompressed BCF output (force -b). Consensus&#x2F;Variant Calling Options:-c Call variants using Bayesian inference. This option automatically invokes option -e.-d FLOAT When -v is in use, skip loci where the fraction of samples covered by reads is below FLOAT. [0] 当有多个sample用于variants calling时,比如多个转录组数据或多个重测序 数据需要比对到参考基因组上,设置该值,表明至少有该&lt;float 01&gt;比例的 samples在该位点都有覆盖才计算入variant.所以对于只有一个sample的情况 下,该值设置在01之间没有意义,大于1则得不到任何结果。-e Perform max-likelihood inference only, including estimating the site allele frequency, testing Hardy-Weinberg equlibrium and testing associations with LRT.-g Call per-sample genotypes at variant sites (force -c)-i FLOAT Ratio of INDEL-to-SNP mutation rate [0.15]-p FLOAT A site is considered to be a variant if P(ref|D)-t FLOAT Scaled muttion rate for variant calling [0.001]-T STR Enable pair&#x2F;trio calling. For trio calling, option -s is usually needed to be applied to configure the trio members and their ordering. In the file supplied to the option -s, the first sample must be the child, the second the father and the third the mother. The valid values of STR are ‘pair’, ‘trioauto’, ‘trioxd’ and ‘trioxs’, where ‘pair’ calls differences between two input samples, and ‘trioxd’ (‘trioxs’) specifies that the input is from the X chromosome non-PAR regions and the child is a female (male). [null]-v Output variant sites only (force -c)Contrast Calling and Association Test Options:-1 INT Number of group-1 samples. This option is used for dividing the samples into two groups for contrast SNP calling or association test. When this option is in use, the following VCF INFO will be outputted: PC2, PCHI2 and QCHI2. [0]-U INT Number of permutations for association test (effective only with -1) [0]-X FLOAT Only perform permutations for P(chi^2) 使用bcftools得到variant calling结果后。需要对结果再次进行过滤。主要依据比对结果中第8列信息。其中的 DP4 一行尤为重要,提供了4个数据:1 比对结果和正链一致的reads数、2 比对结果和负链一致的reads数、3 比对结果在正链的variant上的reads数、4 比对结果在负链的variant上的reads数。可以设定 (value3 + value4)大于某一阈值,才算是variant。比如: 1$ perl -ne &#39;print $_ if &#x2F;DP4&#x3D;(\\d+),(\\d+),(\\d+),(\\d+)&#x2F; &amp;&amp; ($3+$4)&gt;&#x3D;10 &amp;&amp; ($3+$4)&#x2F;($1+$2+$3+$4)&gt;&#x3D;0.8&#39; snp_indel.vcf &gt; snp_indel.final.vcf 12. samtools rmdupNGS上机测序前需要进行PCR一步,使一个模板扩增出一簇,从而在上机测序的时候表现出为1个点,即一个reads。若一个模板扩增出了多簇,结 果得到了多个reads,这些reads的坐标(coordinates)是相近的。在进行了reads比对后需要将这些由PCR duplicates获得的reads去掉,并只保留最高比对质量的read。使用rmdup命令即可完成. 12345678910111213141516Usage: samtools rmdup [-sS] -s 对single-end reads。默认情况下,只对paired-end reads-S 将Paired-end reads作为single-end reads处理。$ samtools input.sorted.bam output.bamsam 和 bam 格式转换BAM转换为SAMsamtools view -h -o out.sam out.bam SAM转换为BAMsamtools view -bS out.sam &gt;out.bam-b 意思使输出使BAM format-S 意思使输入使SAM,如果@SQ 缺剩, 要写-t 所以如果没有@SQsamtools faidx ref.fasamtools view -bt ref.fa.fai out.sam &gt; out.bam REF:http://www.chenlianfu.com/?p=1399http://en.wikipedia.org/wiki/SAMtoolshttp://www.htslib.org/doc/samtools-1.1.htmlhttp://sourceforge.net/projects/samtools/files/http://samtools.sourceforge.net/samtools.shtml","tags":[{"name":"二代测序","slug":"二代测序","permalink":"https://liangbilin.github.io/tags/%E4%BA%8C%E4%BB%A3%E6%B5%8B%E5%BA%8F/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"Python类和对象","date":"2019-10-31T16:00:00.000Z","path":"2019/11/01/Billy--Python类和对象/","text":"(一) 面向过程和面向对象编程面向过程就是分析出解决问题所需要的步骤,然后一步一步地实现。 面向对象是把构成问题事务分解成各个对象,建立对象的目的不是为了完成一个步骤,而是为了描叙某个事物在整个解决问题的步骤中的行为。 例如,五子棋,面向过程的设计思路就是首先分析问题的步骤: 1、开始游戏,2、黑子先走,3、绘制画面,4、判定输赢,5、轮到白子,6、绘制画面,7、判定输赢,8、返回步骤2,9、输出最后结果。 把上面每个步骤用分别的函数来实现,问题就解决了。 而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为: 1、黑白双方,这两方的行为是一模一样的,2、棋盘系统,负责绘制画面,3、规则系统,负责判定诸如犯规、输赢等。 第一类对象(玩家对象)负责接受用户输入,并告知第二类对象(棋盘对象)棋子布局的变化,棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化,同时利用第三类对象(规则系统)来对棋局进行判定。 (二) 类和对象在面向对象编程的基础之上,衍生出了类和对象的概念。类是对客观世界中事物得抽象,而对象是类实例化后的实体。例如,汽车模型就是一个类,制造出来的每辆汽车就是一个对象。 &lt;1&gt; 在Python中创建类 python使用class关键字定义一个类,类名的首字母一般要大写,例如: 12class Person: pass 类的主体由一系列的属性和方法组成,这里介绍类属性的操作。 增加类属性的两种方式 增加类属性的第一种方式为:先定义好类之后,在后面的代码中来增加。形式是:类.属性 = 值 12345678910# 先定义一个类class Person: pass# 增加类属性Person.age = 18Person.sex = \"男\"# 验证属性增加结果print(Person.__dict__) 增加类属性的第二种方式为:在定义类的过程中,定义属性。 1234567# 定义类和类属性class Person: age = 18 sex = \"男\"# 验证类属性增加结果print(Person.__dict__) 在实践过程中,第二种方式更加的常用,第一种方式在某些特定的编程情景中可能更加的方便。 通过del语句删除类属性 12# 例如我们要删除上面定义的Person类的age属性del Person.age 通过赋值的方式修改类属性 123456789class Person: age = 18 sex = \"男\"# 如我们要修改age属性为66Person.age = 66# 查看修改的结果print(Person.age) &lt;2&gt; 实例化对象12345678910111213# 先创建一个类class Person: age = 18 sex = \"男\"# 实例化对象P = Person()# 增加对象属性P.height = 180# 查看修改的结果print(P.__dict__) &lt;3&gt; 类和对象的内存存储当创建一个类之后,会在计算机内存中开辟一个空间,用于存储类,同时也会开辟出空间用于存储各个属性值。而所谓类.属性则是记录的是指向属性值的指针信息。 当修改属性的值时,会在内存空间重新开辟一个空间,存储新的值。然后将指针指向该新的值。 &lt;4&gt; 类的方法类的主体为方法和属性,而方法的定义有三种方式:1 实例方式、2 类方式、3 静态方式。 通过实例方式定义类方法 从下面的代码可以看到,方法是定义在类中的。另外,通过实例方式定义的方法,第一个参数是self,这个参数指的是调用时候的实例,如下述代码中,该参数指的就是实例P。 12345678# 首先定义类class Person: # 通过实例方式来进行定义。 def eat(self, food): print(\"在吃\", food)# 调用类的方法P = Person()P.eat('土豆') 通过类方式定义类方法 需要借助装饰器@classmethod进行定义,在定义方法前面,需要申明装饰器。此外,注意到方法中第一个参数为cls,即class的简写。它的含义为类,如下述代码中,cls的意义为Person类。 这种方式,也可以在实例层次上调用类。如果实在实例层次上调用,默认会将实例所对应的类,作为 cls 参数的输入。 123456789101112# 定义类,通过类方式来定义类方法class Person: @classmethod def eat(cls, food): print(\"在吃\", food)# 在类层次上调用类方法Person.eat('土豆')# 在实例层次上调用类方法P = Person()P.eat('土豆') 通过静态方式定义类方法 需要借助装饰器@staticmethod进行定义,在定义方法前面,需要申明装饰器。 1234class Person: @staticmethod def eat(food): print(\"eating\", food) &lt;5&gt; 类方法的三种定义方式区别通过实例方式定义的类方法,既可以调用类属性,也可以调用调用实例添加的实例属性,如Person.age和P.num都可以被这种方式调用。 类方式定义的方法,只可以调用类属性(Person.age),而不能调用实例属性(P.num)。 静态方法定义的方法,既不能调用类属性,也不能调用实例属性。 12345678910111213141516171819202122232425262728# 首先定义一个类class Person: age = 18 #定义一个类属性 #通过实例方式定义方法 def shilifangfa(self): print(self) print(self.age) print(self.num) #通过类方式定义类方法 @classmethod def leifangfa(cls): print(cls) print(cls.age) print(cls.num) #通过静态方式定义类方法 @staticmethod def jingtaifangfa(): print(Person.age) #想要调用类属性,必须注明类名称# 实例方法调用P = Person()P.num = 11P.shilifangfa() #不会报错P.leifangfa() #会报错,因为无法调用P.numP.jingtaifangfa() (三) 类属性和方法的注释文档&lt;1&gt; 代码中的格式规则1:在定义类后的第一行,使用三个双引号来添加类注释信息。注释信息应包含该类的作用、构造函数等描述。 规则2:类属性的注释放在“规则1”部分,并用如 Attributes 关键字来标记。 规则3:在定义类方法的第一行,使用三个双引号来添加类方法注释信息。在PyCharm中,编写完成方法后,再添加注释信息,会自动化补全参数注释格式,如下面代码中的:param distance:。 规则4:定义完类之后,可以使用help()方法来查看注释信息。 12345678910111213141516171819class Person: \"\"\" 第一,关于类的描述,类的作用,类的构造函数等等 第二,描述类的属性 Attributes: name: string \"\"\" name = \"Billy\" def run(self, distance): \"\"\" 描述这个方法的作用等。 :param distance: 参数的含义、参数输入类型、是否有默认值等 :return: \"\"\" print(self.name, \"is running.\") print(\"He has run for \", distance, \"mile.\") return distancehelp(Person) #可以打印出注释信息 help()查看的注释信息如下: 1234567891011121314151617181920212223242526class Person(builtins.object)| 第一,关于类的描述,类的作用,类的构造函数等等| 第二,描述类的属性| Attributes:| name: string| | Methods defined here:| | run(self, distance)| 描述这个方法的作用等。| :param distance: 参数的含义、参数输入类型、是否有默认值等| :return:| | ----------------------------------------------------------------------| Data descriptors defined here:| | __dict__| dictionary for instance variables (if defined)| | __weakref__| list of weak references to the object (if defined)| | ----------------------------------------------------------------------| Data and other attributes defined here:| | name &#x3D; &#39;Billy&#39; &lt;2&gt; 生成注释文档在编写复杂的程序时,就会定义非常多的类。此时,使用help()方法是不可行的。我们就可以借助Python的标准模块pydoc,以生成html格式的注释文件。 在上述代码文件目录下,打开终端,并输入下面的命令: 1python -m pydoc -b 完成后,将在默认浏览器中开启一个网页,可以看到我们编写的类文件注释信息。 当然,也可以指定生成某个特定类文件的注释信息文件,如下。完成后将在该目录下产生一个html文件。 1python -m pydoc -w leiwenjian.py &lt;3&gt; 函数的注释顺便提一下函数的注释规则,与类方法的注释规则很像,如下。 12345def food(name): \"\"\" 函数的注释信息 \"\"\" print(\"the food is \", name)","tags":[{"name":"Python","slug":"Python","permalink":"https://liangbilin.github.io/tags/Python/"}]},{"title":"PyCharm 使用教程","date":"2019-10-21T16:00:00.000Z","path":"2019/10/22/Billy--PyCharm 教程/","text":"Python的IDE有很多，例如之前所使用的Jupyter notebook（比较适合于机器学习、神经网络）、Python自带IDE、甚至notebook++。但这些都仅适合轻量级代码编写，除了Jupyter notebook之外，其他IDE也不具备代码补齐功能。 PyCharm具备代码补齐、可远程连接服务器等优点，更加适合复杂的代码编写。 新建项目 配制解释器 配制外观风格 设置编码为 utf-8 设置脚本头设置脚本头之后,可以在以后新建Python脚本时候,都会自动出现该内容 快捷方式全部快捷方法可以在设置中查看 shift + Enter 快速换行Ctrl + / 批量注释和去注释 查看文档-结构可以方便的查看脚本的整体结构信息。举例如下,先打开python内置标准模块os的源码 可以看到os模块源码的整体结构信息。 TODOTODO本身是为了在需要长时间完成的大型项目中,作为备忘录的功能。 设置Tab键等于4个空格","tags":[{"name":"Python","slug":"Python","permalink":"https://liangbilin.github.io/tags/Python/"}]},{"title":"PyCharm最新版永久破解教程","date":"2019-10-11T16:00:00.000Z","path":"2019/10/12/Billy--PyCharm最新版永久破解教程/","text":"PyCharm 最新版永久破解教程(2019年10月12日)软件程序及破解资源下载PyCharm程序分为免费的社区版本和收费的专业版本。专业版本可以从其官方网站下载,但是为了和破解资源匹配,这里提供了2019年10月12日下载的Windows软件程序。百度云网盘链接如下: 123https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1_PCd8uSMWzVP3sLm8VOW8g 提取码: uqyj 从百度云网盘下载的压缩包文件包含了PyCharm Windows平台程序和破解资源jetbrains-agent-latest。 安装PyCharm双击pycharm-professional-2019.3.2.exe,安装默认参数安装即可。 破解PyCharm程序在jetbrains-agent-latest文件目录中,包含了一个破解方法文件。 先下载压缩包解压后得到jetbrains-agent.jar,把它放到你认为合适的文件夹内。 如果你是无外网环境,将jetbrains-agent.jar更名为jetbrains-agent-offline.jar 下载页面:https://zhile.io/2018/08/17/jetbrains-license-server-crack.html 启动你的IDE,如果上来就需要注册,选择:试用(Evaluate for free)进入IDE 点击你要注册的IDE菜单:”Configure” 或 “Help” -&gt; “Edit Custom VM Options …” 如果提示是否要创建文件,请点”Yes”。 参考文章:https://intellij-support.jetbrains.com/hc/en-us/articles/206544869 在打开的vmoptions编辑窗口末行添加:-javaagent:/absolute/path/to/jetbrains-agent.jar 一定要自己确认好路径(不要使用中文路径),填错会导致IDE打不开!!!最好使用绝对路径。 一个vmoptions内只能有一个-javaagent参数。 示例: mac: -javaagent:/Users/neo/jetbrains-agent.jar linux: -javaagent:/home/neo/jetbrains-agent.jar windows: -javaagent:C:\\Users\\neo\\jetbrains-agent.jar 如果还是填错了,参考这篇文章编辑vmoptions补救: https://intellij-support.jetbrains.com/hc/en-us/articles/206544519 重启你的IDE。 点击IDE菜单 “Help” -&gt; “Register…” 或 “Configure” -&gt; “Manage License…” 支持两种注册方式:License server 和 Activation code: 1). 选择License server方式,地址填入:http://jetbrains-license-server (应该会自动填上)或者点击按钮:&quot;Discover Server&quot;来自动填充地址。网络不佳的见第2种方式。 2). 选择Activation code方式离线激活,请使用:ACTIVATION_CODE.txt 内的注册码激活如果激活窗口一直弹出(error 1653219),请去hosts文件里移除jetbrains相关的项目 License key is in legacy format == Key invalid,表示agent配置未生效。 如果你需要自定义License name,请访问:https://zhile.io/custom-license.html","tags":[{"name":"Python","slug":"Python","permalink":"https://liangbilin.github.io/tags/Python/"}]},{"title":"Nanopore Sequencing 概述","date":"2019-10-01T16:00:00.000Z","path":"2019/10/02/Billy--Nanopore Sequencing 概述/","text":"为什么要选择 Nanopore 测序?(一) 超长读长 在纳米孔测序中,读长长度可以等于输入片段长度。读长长度不受限于测序设备,用户可以通过所使用的文库制备实验方案来控制片段长度。目前报到处DNA片段长度最高记录为&gt;2 Mb,直接RNA测序读长最长为26kb。长读长提供了一个更明确的方法来比对和匹配DNA或RNA序列,提供高质量、更完整、更连续的基因组组装。在类如植物基因组和具有大型结构变异和高水平重复区域的基因组中优势显著。 (二) 直接测序 纳米孔技术基于电子学原理,允许直接测序原始DNA和RNA。不需要通过DNA拷贝、进行链合成或使用亚硝酸盐进行转化,这不仅节省了时间和成本,还意味着碱基修饰的信息(例如5mC,pseudouridine,m6A)会被完整的保留,并且包含在测序运行产生的原始信号信息中,随时进行分析。由于纳米孔技术支持无需PCR的直接测序,也就没有了扩增偏好性,并且文库制备工作流程也更简单。 (三) 实时测序 与在运行结束时批量交付数据的传统测序技术不同,纳米孔技术提供的是动态、实时的测序,支持在几分钟内就获得病原体鉴定等时间关键型应用的检测结果。测序时,DNA快速通过纳米孔。DNA片段通过纳米孔的速率已从推出时的每秒35个碱基提升到了现在每秒450个碱基。每一个在阵列上完成的读长,在数秒后就可以用来开始数据分析,而不是几小时甚至几天。用户可以在测序早期了解样本的质量和状态,也可以在获得足够的数据后停止测序。快速的采样到结果周转时间在未来感染性疾病、实地动态监测疫情爆发以及其它诊断方面具有巨大潜力。 (四) 按需要测序 与传统测序技术不同的是,在纳米孔测序中,用户可以自行掌握测序时间、地点、以及需要使用的芯片数量。例如,可以单次使用的最小型的测序芯片Flongle适合快速质量检测、小型基因组实验和靶向测序。便携式测序仪MinION,重量不足100g,可以被带到任何地方测序任何样本。台式测序仪GridION和PromethION分别具有5个和24或者48个测序芯片,每个芯片可以独立运行,也可以同时使用,并结合实时的数据传送。这意味着用户可以根据样本的数量选择芯片数量,随数据量要求随时启动和停止实验。 (五) 启动费用低 传统的高通量测序价格昂贵,启动需要数十万至百万人民币。而纳米孔测序目前启动套装只需要17271元,包括MinION测序仪,两张测序芯片,一盒建库试剂盒,一盒清洗试剂盒。两张芯片最多可以测序60G数据。 (六) 灵活、可扩展 所有Oxford Nanopore测序设备使用同样的核心技术,用户可以轻松根据应用测试实验以及扩大或缩小规模。从最小型的Flongle和掌上MinION,到桌面型的GridION和PromethION。所有设备都可用于进行按需测序实验。包括从单次试验到超高通量项目,全部都可提供快速、长读长、实时的DNA或RNA直接测序。用于纳米孔测序的DNA或RNA建库过程简单直接,最快的建库方法只需5到10分钟就可在样本分子末端添加测序接头及马达蛋白。 Nanopore 测序的典型应用(一) 大基因组拼接 nanopore最显著特点就是读长长。长读长对于大基因组的拼接将会产生立竿见影的效果。在以往基于短片段的基因组拼接中,由于一些动植物基因组本身具有多倍体,高度重复,高度杂合的特性,导致基因组拼接是一项异常艰难的工作,有些植物甚至复杂到利用短片段根本无法完成拼接工作,例如基因组大小高达152Gb的重楼百合 (Paris japonica),还有10倍体的择捉草莓 (Fragaria turupensis)等。虽然后来有了大片段文库,BAC文库,optical mapping光学图谱,Hi-C,bionano等辅助技术,但依然无法从根本上解决大型基因组拼接的问题。而nanopore测序技术将从根本上改变大型基因组拼接技术难题,根据百迈克公司公开发布的数据来看。利用三代测序可以极大的提高基因组的完整性contig数目减少,N50长度可以达到M级别,同时配合多轮纠错机制,拼接的准确性也非常高。 (二) 细菌完成图 由于细菌基因组比较小,通常小于10M,大部分是一条染色体,并且由于细菌基因组通常重复序列不多,利用nanopore的长读长的特性,甚至可以一次性拼接出完整的基因组。笔者以前做过上千微生物基因组拼接,当时需要利用短片段多文库的策略拼接细菌完整图,折腾一个多月也无法彻底解决大的重序列的问题,而现在利用nannopor测序,只需几分钟(根据具体样品和硬件配置不同)就可以拼出一条完整的基因组(我们后面会有具体的推文)。 (三) 全长无偏倚转录组 以往的转录组分析,由于无法直接对RNA进行测序,往往需要先对mRNA进行打断,在反转录为cDNA。反转录过程中PCR可能会引入扩增偏差,导致筛选到假阳性的表达差异基因,尽管目前采用单细胞加UMI特异标签的方法减少PCR偏差。但依然无法获取和分析全长转录本,由于真核生物普遍存在的剪切差异,短读长测序依然无法准确识别,而利用nanopore的长读长测序,可以准确识别各基因的多个同源异构体,简单准确。并且nanopore可以对RNA直接测序,这样就能够直接识别RNA的碱基修饰。 (四) 大片段结构变异 目前的基因组突变分析主要在单碱基突变SNP,以及少量的插入缺失(InDel)上,而忽略掉基因组上含量巨大的大的结构变异。这主要是因为仅使用短测序读长时,无法准确检测这些变异,例如缺失、插入、重复、倒位和易位。但已有研究表明,这些重复区域和结构变异与人类的健康和疾病有关(例如,老龄化、三联体扩张疾病、自闭症、癫痫和癌症),使得对它们进行的常规表征鉴定非常有利。利用nanopore长读长的特点,非常适合进行大片段结构变异的检测。 (五) 突变定相分析 所谓定相分析,被称为Phasing,简单来说就是将一个二倍体(甚至是多倍体)基因组上的等位基因信息,判断出其遗传自父本还是母本,最终使得所有来自同一个亲本的信息都能够排列在同一条染色体里面。很显然,测序的长度越长对定相分析越有利(如果是完整一条就直接比对就行了)。根据文献报道,利用超长读长不仅使组装连续性提高了一倍(NG50~6.4MB),而且显著改善了定相(phasing)等位基因的功能。例如,有可能对包含在单个16 MB contig中的整个4 MB主要组织相容性复合体(MHC)进行定相(phasing)。 (六) 微生物快速鉴定 利用nanopore测序,实时,快速的特点,非常适合为微生物的快速鉴定。可以在采集点分析直接进行测序,而且实时的basecalling,上机几分钟之后就可以有序列产出,可以直接使用序列进行物种分类鉴定。从样本到检测结果用时大大减少。据报道,使用MinION在北极环境中从样本采集到测序数据生成仅需不到40小时。 Nanopore 测序原理Nanopore 测序是将人工合成的一种多聚合物的膜浸在离子溶液中,多聚合物膜上布满了经改造的穿膜孔的跨膜通道蛋白(纳米孔),也就是Reader蛋白。在膜两侧施加不同的电压产生电压差,DNA链在马达蛋白的牵引下,解螺旋通过纳米孔蛋白,不同的碱基会形成特征性离子电流变化信号。该膜具有非常高的电阻。通过对浸在电化学溶液中的膜上施加电势,可以通过纳米孔产生离子电流。进入纳米孔的单分子引起特征性的电流干扰,这被称为Nanopore信号。 Nanopore 测序数据格式Nanopore 测序时需要使用一款名为 MinKNOW 的软件。MinKNOW 是 Nanopore 测序所有平台的驱动操作软件,主要功能包括控制仪器,测序与实时碱基识别,检测运行状态,数据采集。在运行之前,可以选择测序输出文件是 FAST5格式 还是 FASTQ格式 。 FASTQ 格式是一种带有碱基和质量值的序列文件,目前是测序行业非常标准的文件格式。目前作为illumina,Ion Torrent,BGIseq,Pacbio,nanopore等平台通用的测序文件表示形式,这样后续很多软件可以通用。 FAST5 格式存储了Nanopore测序过程中全部的输出信息。里面记录着设备运行时全部的信息,包括捕获的电信号值,设备运行时间,电压,温度等等信息。 FAST5 格式FAST5是HDF5文件格式的一个变种,而HDF(Hierarchical Data Format),是一种设计用于存储和组织大量数据的文件格式,一般扩展名为.hdf5或.h5,表示现在使用的版本是第五个版本。这是一种分级的数据文件,可以存储不同类型的图像和数码数据的文件格式,并且可以在不同类型的机器上传输,同时还有统一处理这种文件格式的函数库。fast5里面可以包含很多的内容,并且可以继续添加。简单理解,这种文件类似于一个经过压缩的文件夹,里面包含很多文件,如下图所示: nanopore测序过程中,一个纳米孔测序完一条序列,则可以输出一个fast5文件,一个MinION的flowcell就生成10-20Gb的数据量,有几百万的条reads,这百万千万级别的文件处理就是一个大麻烦,需要反复打开关闭IO,完成一次文件拷贝和统计要花很长时间。19年以前的fast5文件是一条序列一个fast5文件,现在新的MinKNOW做了升级,可以设定生成multi_fast5文件,一个fast5包含的reads数目可以自己设定,一般4,000。 如何查看fast5格式文件可以使用软件 HDFView 查看FAST5文件格式。 https://www.hdfgroup.org/downloads/hdfview/ FAST5格式文件的优缺点FAST5格式的优点是内容非常全,可以存储所有的信息。缺点也非常明显,就是占用空间特别大。例如,23M左右的碱基序列,存储为fastq格式大概45M,压缩之后大约是23M;而原始的fast5文件则需要占用613M的存储,大约30倍。如果是测序一个MiniION 30G的碱基,则大概需要将近1T的存储。 拆分与合并fast5格式有时候,一条测序读长被保存在一个FAST5文件,有时候一个FAST5文件可能保存了多条读长。 123456789#ont_fast5_api 网址#https:&#x2F;&#x2F;github.com&#x2F;nanoporetech&#x2F;ont_fast5_api#安装#直接使用pip安装pip install ont-fast5-api#自行编译安装git clone https:&#x2F;&#x2F;github.com&#x2F;nanoporetech&#x2F;ont_fast5_apicd ont_fast5_apipython3 setup.py install 使用案例 12345#多条读长合并为一个文件single_to_multi_fast5 -i fast5_files&#x2F; -s multi -n 4000 --recursive#一个文件拆分为多条读长multi_to_single_fast5 -i multi&#x2F; -s single --recursive -t 6","tags":[{"name":"纳米孔测序","slug":"纳米孔测序","permalink":"https://liangbilin.github.io/tags/%E7%BA%B3%E7%B1%B3%E5%AD%94%E6%B5%8B%E5%BA%8F/"}]},{"title":"使用poretools处理fast5格式数据","date":"2019-09-20T16:00:00.000Z","path":"2019/09/21/Billy--使用poretools处理fast5格式数据/","text":"目前三代测序主要为PacBio公司的SMRT测序技术和Oxford Nanopore Technology的纳米孔测序技术。相比于第一代和第二代测序技术,三代测序技术最为核心的特点就是单分子和长读长。第三代测序下机数据以fast5 (本质上为HDF5格式)格式存储。 HDF5的文件组织:一个HDF5文件就是一个由两种基本数据对象(groups and datasets)存放多种科学数据的容器: HDF5 group:包含0个或多个HDF5对象以及支持元数据(metadata)的一个群组结构。 HDF5 dataset:数据元素的一个多维数组以及支持元数据(metadata)。 （一） 安装anaconda(或 minianaconda)网上很多教程,此处省略… （二） 通过conda安装poretools 创建虚拟环境 1conda create -p ~/envs/poretools 检索bioconda中收录的poretools版本信息 1conda search poretools 根据检索结果,确定下载的版本 1conda install -p ~/envs/poretools poretools=0.6.0 使用之间,激活该虚拟环境 123conda activate ~/envs/poretools# 推出激活命令为:conda deactivate ~/envs/poretools （三） 使用教程 提取FASTQ格式序列 123poretools fastq test.fast5#批量提取poretools fastq *.fast5 提取FASTA格式序列 1poretools fasta test.fast5 绘制电信号曲线 1poretools squiggle test.fast5 其他测序指标统计,参照官方资料 参考资料https://poretools.readthedocs.io/en/latest/content/examples.html#poretools-fastq","tags":[{"name":"纳米孔测序","slug":"纳米孔测序","permalink":"https://liangbilin.github.io/tags/%E7%BA%B3%E7%B1%B3%E5%AD%94%E6%B5%8B%E5%BA%8F/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"转录组差异表达分析--免比对工具kallisto","date":"2019-09-06T16:00:00.000Z","path":"2019/09/07/Billy--转录组差异表达分析——kallisto/","text":"（一） RNA-seq概述RNA-seq是研究转录组应用最广泛,也是最重要的技术之一。RNA-seq分析内容包括序列比对、转录本拼接、表达定量、差异分析、融合基因检测、可变剪接、RNA编辑和突变检测等,具体流程和常用工具如下图所示。通常的分析不一定需要走完全部流程,按需进行,某些步骤可以跳过、简化等。 RNA-seq中最常用的分析方法就是找出差异表达基因(Differential gene expression, DEG)。在实验室中,标准流程就分为三步: step1:构建测序文库。包括提取RNA,富集mRNA或清除核糖体RNA,合成cDNA,加上接头。 step2:在高通量测序平台(通常为Illumina)上对文库进行测序,每个样本的测序深度为10-30M读长。 step3:数据分析。具体而言:对测序得到的读长进行比对或组装到转录本上;对覆盖到每个基因区域的读长进行计数;根据统计模型鉴定不同样本间差异表达的基因。(这种分析过程是比较传统的方法) （二） 差异表达分析——免比对工具kallisto2016年4月4日,Nature Biotechnology 杂志上发表了一篇题为“Near-optimal probabilistic RNA-seq quantification”的论文,主要介绍一个RNA-seq数据量化软件kallisto。传统的RNA-seq数据分析思路需要将测序数据先比对到参考基因组上(tophat2、bowtie2、HISAT2等软件),然后从比对结果中对覆盖到每个基因区域的读长进行计数并计算表达量。 这篇论文介绍的kallisto最大的优势在于保证了量化分析准确性的前提下,去掉了比对步骤,极大降低了计算资源的需求。而它的原理是基于一个被证明的理论,即read具体比对到参考基因的什么位置并不影响最终表达量的计算,换句话说只需要确定这个read属于该基因即可,具体它在基因的哪个区域并不重要。 （三） 简明教程安装kallisto 通过Bioconda安装: 12345678# 创建虚拟环境conda create -n kallisto# 在虚拟环境中安装kallistoconda install -n kallisto kallisto# 激活虚拟环境conda activate kallisto 构造索引文件 在ensembl、UCSC或NCBI网站上可下载对应物种的FASTA格式的cDNA文件。 使用kallisto软件对物种的cDNA文件构建索引文件: 123456# 选择kallisto的index模块kallisto index -i hg38.idx Homo_sapiens.GRCh38.cdna.all.fa# -i 产生的索引文件# Homo_sapiens.GRCh38.cdna.all.fa 为物种的cDNA文件名 基因表达定量 双端测序数据分析过程: 123456# 选择kallisto的quant模块kallisto quant -i hg38.idx -o output test.R1.fq.gz test.R2.fq.gz# -i 上一个步骤建立的索引文件# -o 输出文件目录名,会创建一个输出目录,里面默认会产生三个文件:abundance.h5(h5格式的定量结果)、abundance.tsv(文本格式的定量结果)、run_info.json(程序log记录)# -t 调用线程数 单端测序数据分析过程: 123456kallisto quant -i hg38.idx -o output --single -l 200 -s 20 test1.fq.gz # --single 参数指定为单端测序数据# -l 估计的reads平均长度# -s 估计的reads片段长度标准差# -l 和 -s 参数值可以通过类似Agilent Bioanalyzer软件估算 （四） 参考资料 https://wenku.baidu.com/view/21c4991d76232f60ddccda38376baf1ffc4fe3a8.html","tags":[{"name":"二代测序","slug":"二代测序","permalink":"https://liangbilin.github.io/tags/%E4%BA%8C%E4%BB%A3%E6%B5%8B%E5%BA%8F/"},{"name":"转录组","slug":"转录组","permalink":"https://liangbilin.github.io/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/"}]},{"title":"转录组差异表达分析概述","date":"2019-08-31T16:00:00.000Z","path":"2019/09/01/Billy--转录组差异表达分析概述/","text":"（一） RNA-seq概述RNA-seq是研究转录组应用最广泛,也是最重要的技术之一。RNA-seq分析内容包括序列比对、转录本拼接、表达定量、差异分析、融合基因检测、可变剪接、RNA编辑和突变检测等,具体流程和常用工具如下图所示。通常的分析不一定需要走完全部流程,按需进行,某些步骤可以跳过、简化等。 RNA-seq中最常用的分析方法就是找出差异表达基因(Differential gene expression, DEG)。在实验室中,标准流程就分为三步: step1:构建测序文库。包括提取RNA,富集mRNA或清除核糖体RNA,合成cDNA,加上接头。 step2:在高通量测序平台(通常为Illumina)上对文库进行测序,每个样本的测序深度为10-30M读长。 step3:数据分析。具体而言:对测序得到的读长进行比对或组装到转录本上;对覆盖到每个基因区域的读长进行计数;根据统计模型鉴定不同样本间差异表达的基因。 （二） 差异基因表达的RNA-seq数据分析流程主流的分析流程有三种,如下图分别用A、B、C三个方框表示的流程,虚线表示替代工具。 &lt;1&gt; 传统分析流程上图的A分析流程是比较传统的分析方法,具体过程为: 通过比对工具如TopHat、STAR或HISAT2等工具将测序读长数据比对回帖到参考基因组; 然后使用一些定量工具如HTSeq或featureCounts对比对到每个基因区域的读长进行计数; 通过Excel或编程语言脚本产生一个列为样本、行为基因、填充数值为读长数目的基因表达矩阵; 为克服样本间测序深度的差异,需做TMM或FPKM等归一化处理; 通过edgeR、DESeq2或limma+voom等统计工具进行差异表达分析,得到差异表达基因; 进一步可视化或功能分析… &lt;2&gt; 免比对分析流程上图的B分析流程是较新的免比对分析方法,Kallisto 或 Salmon这些工具会在一步操作中组装转录本并对相应的转录本进行定量,然后通过与A分析流程中相同的归一化和统计分析,得到差异表达基因。 &lt;3&gt; 通过转录本估计丰度的分析流程这种分流思路是先将测序数据比对到参考基因组,然后将短读长组装为转录本,最后估计转录本的丰度。例如在C分析流程中,首先于传统分析流程一样,需使用TopHat、STAR或HISAT2等工具将测序读长数据比对回帖到参考基因组;然后使用CuffLinks将短读长拼接成转录本;之后使用CuffDiff2来输出转录本丰度的估计值,以及一个差异表达基因或转录本的列表。 其它常用工具还包括StringTie,这个工具使用TopHat(或类似工具)的比对结果来组装一个转录本模型,然后利用RSEM 或 MMSEQ估计转录本丰度值。最后将转录本的丰度值输出给Ballgown来计算差异表达基因或转录本。 SOAPdenovo-trans这个工具则能同时对读长进行比对和组装,其结果输入给RSEM或MMSEQ以估计转录本丰度。 （三） 转录组分析工具比较RNA-seq数据分析常用工具如下: Nature Communication有一篇文章”Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis”对39个分析工具的120种常见组合方式进行了分析,总结了一套比较普适性流程。 表达定量分析工具比较 不同分析工具的准确度和分析时间是有差异的,具体而言: HISAT2表现出最快的速度和最准确的拼接比对,但是敏感度不如STAR; StringTie在速度和准确性都优于Cufflinks; 免比对工具Salmon-SMEM和kallisto表现了最好的一致性和最高准确度,因此如果不是发现新的转录本,这两个工具可以作为快速而准确的方案。 DESeq2和edgeR与免比对工具kallisto或Salmon-SMEM联用,可以获得高准确度的差异表达分析结果; 差异表达基因鉴定工具比较 有多种方法鉴定差异表达基因,包括基于计数 (reads count)的DESeq、limma和edgeR、基于组装技术的Cuffdiff和Ballgown、不经过比对定量进行差异分析的sleuth。 DESeq2在所有组合中表现最佳,sleuth、edgeR和limma略微次之,但差别不大。 Cuffdiff和Ballgown的准确度没有基于计数的工具准确度高。 基于计数的工具比基于组装的工具更高效, 免比对直接定量的工具如Salmon和kallisto能够获得高质量的差异分析结果。 推荐使用的软件组合形式: 基于“比对 + 组装 + 定量”: HISAT2:用于比对;StringTie用于转录本组装;RSEM用于估计转录本丰度; 基于“比对 + 计数 + 定量”: HISAT2或STAR或TopHat:用于比对;DESeq2:用于定量 基于免比对: Salmon-SMEM或kallisto:用于计数;sleuth或DESeq2:用于定量 ###（四） 参考资料 https://blog.csdn.net/qazplm12_3/article/details/76700045 https://mp.weixin.qq.com/s/a3y46NNNO-wardO3XWwh0w","tags":[{"name":"二代测序","slug":"二代测序","permalink":"https://liangbilin.github.io/tags/%E4%BA%8C%E4%BB%A3%E6%B5%8B%E5%BA%8F/"},{"name":"转录组","slug":"转录组","permalink":"https://liangbilin.github.io/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/"}]},{"title":"R语言的Jupyter notebook环境搭建","date":"2019-08-24T16:00:00.000Z","path":"2019/08/25/Billy--R语言的Jupyter notebook环境搭建/","text":"简介之前在 Jupyter notebook server 搭建 一文中,我们介绍了:非root用户如何在Linux服务器下搭建jupyter notebook环境,并通过本地电脑的浏览器连接该环境进行编程。但是该环境只包含了Python语言,如果想要使用R语言,则需要根据本文进行下述操作。 安装R语言 可以在官方网站进行下载安装,这里介绍一篇相关的 教程文章 使用Miniconda 或 conda 进行安装。例如,我们使用之前已经安装好的Miniconda来进行R语言的安装。12# 查看conda包含的R语言版本信息conda search R 得到以下的输出结果: 12345678910111213141516171819202122Loading channels: done# Name Version Build Channelr 3.1.2 0 pkgs&#x2F;rr 3.1.2 1 pkgs&#x2F;rr 3.1.2 2 pkgs&#x2F;rr 3.1.2 3 pkgs&#x2F;rr 3.1.3 0 pkgs&#x2F;rr 3.2.0 0 pkgs&#x2F;rr 3.2.1 0 pkgs&#x2F;rr 3.2.2 0 pkgs&#x2F;rr 3.3.1 r3.3.1_0 pkgs&#x2F;rr 3.3.1 r3.3.1_1 pkgs&#x2F;rr 3.3.2 r3.3.2_0 pkgs&#x2F;rr 3.4.1 r3.4.1_0 pkgs&#x2F;rr 3.4.2 h65d9972_0 pkgs&#x2F;rr 3.4.3 mro343_0 pkgs&#x2F;rr 3.4.3 r343_0 pkgs&#x2F;rr 3.5.0 mro350_0 pkgs&#x2F;rr 3.5.0 r350_0 pkgs&#x2F;rr 3.5.1 mro351_0 pkgs&#x2F;rr 3.5.1 r351_0 pkgs&#x2F;rr 3.6.0 r36_0 pkgs&#x2F;r 这里选择安装最新的 3.6.0 版本进行安装。 12# 根据需求,决定是否另外创建一个虚拟环境。这里直接安装到默认的环境中。conda install R=3.6.0 安装必要的R语言包检查上一步骤中安装的R语言是否成功,以及是否在默认环境中。 1234which R# 我们这里得到如下结果,证明安装的R语言是在默认系统环境里的。# /data/home/bugaosuni/miniconda3/bin/R 直接启动R语言。 1R 在R语言中安装下列的必要包。 12install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))devtools::install_github('IRkernel/IRkernel') 执行完上一个步骤之后,进行以下操作。 12# 只在当前用户下安装IRkernel::installspec()","tags":[{"name":"R","slug":"R","permalink":"https://liangbilin.github.io/tags/R/"}]},{"title":"Python--参数解析包argparse","date":"2019-08-16T16:00:00.000Z","path":"2019/08/17/Billy--Python3包（argparse）学习笔记/","text":"argparse 是python自带的命令行参数解析包,可以用来方便地读取命令行参数,当你的代码需要频繁地修改参数的时候,使用这个工具可以将参数和代码分离开来,让你的代码更简洁,适用范围更广。 基本用法下面是使用argparse从命令行获取用户名,并打印’Hello’ + ‘用户名’。 123456789101112#python3#script name: test.pyimport argparseparser = argparse.ArgumentParser(description='Demo of argparse.')parser.add_argument('--Name', '-n', default='Billy', help='This argument is name. default is \"Billy\"')args = parser.parse_args()name = args.Nameprint('Hello &#123;&#125;'.format(name)) 命令执行结果: 12345678$ python3 test.pyHello Billy$ python3 test.py -n TomHello Tom$ python3 test.py -Name TomHello Tom 上面的代码段中,我们显示引入了argparser包,然后通过argparser.ArgumentParser函数生成parser对象,其中这个函数的description函数表示在命令行显示帮助信息的时候,这个程序的描述信息。可以通过python3 test.py -h显示帮助信息。 之后我们通过对象的add_argument函数来增加参数。其中,--Name表示完整的参数名,在后续编程中使用的必须是这个完整参数名。-n表示简化的参数名,是为了方便程序的使用者。default是可选参数,表示参数的默认值。help是参数的说明信息,在帮助信息中会显示。 参数设置完成后,通过对象的parse_args函数传递给变量args,便于后续编程。 调用参数:通过完整参数名来调用参数内容,如args.Name。 parser.add_argument() 常用参数 完整形参和简化形参 完整形参是必需的,两条横线声明,如上面案例中的 --Name简化形参用一条横线声明,如上面案例中的 -n 2. default 参数默认的值3. required 表示这个参数是否一定需要设置 如果设置了required=True,则在实际运行的时候必需设置此参数,否正程序报错 4. type 参数类型 默认参数类型是字符串(str)。如果程序需要一个整数或布尔值类型的话,则需要设置type=int或type=bool。 5. choices 参数值可选择的选项,如一下代码 12#参数的值只能是alexnet或vggparser.add_argument('-arch', required=True, choices=['alexnet', 'vgg']) 6. dest 设置参数在代码中的变量名 argparse默认的变量名是–或-后面的字符串,但是你也可以通过dest=xxx来设置参数的变量名,然后在代码中用args.xxx来获取参数的值。7. narg 指定该参数后面的参数值个数 使用方式如下: ``pythonparser.add_argument(‘-name’, nargs=x) 12345678910111213141516171819202122232425其中, &#96;x&#96;的候选值和含义如下:&gt; N 参数的绝对个数(例如:3)&gt; &#39;?&#39; 0或1个参数&gt; &#39;*&#39; 0或所有参数&gt; &#39;+&#39; 所有,并且至少一个参数如下例子:&#96;&#96;&#96;python# file-name: nargs.pyimport argparsedef get_parser(): parser &#x3D; argparse.ArgumentParser( description&#x3D;&#39;nargs demo&#39;) parser.add_argument(&#39;-name&#39;, required&#x3D;True, nargs&#x3D;&#39;+&#39;) return parserif __name__ &#x3D;&#x3D; &#39;__main__&#39;: parser &#x3D; get_parser() args &#x3D; parser.parse_args() names &#x3D; &#39;, &#39;.join(args.name) print(&#39;Hello to &#123;&#125;&#39;.format(names)) 执行结果: 12$ python3 nargs.py -name A B CHello to A, B, C","tags":[{"name":"Python","slug":"Python","permalink":"https://liangbilin.github.io/tags/Python/"}]},{"title":"Jupyter notebook server 搭建","date":"2019-08-09T16:00:00.000Z","path":"2019/08/10/Billy--Jupyter notebook server/","text":"背景介绍Jupyter Notebook 的交互界面适用于机器学习、深度学习等开发项目。然而，计算资源一般使用的为Linux服务器，并且多为非Root用户。因此，需要在服务器端提供一个Jupyter Notebook，能够通过本地计算机的浏览器连接并使用该Jupyter Notebook工具。 实现步骤 Linux服务器上安装Python 可选择的安装途径有很多，这里出于后续搭建深度学习框架的需求，选择通过安装Minianaconda的方式进行安装。参照Minicodna 安装教程，在 官方网站 上下载自己所需的版本进行安装。 在服务器上安装Python第三方包：Jupyter notebook 1pip install jupyter 在服务器上配置notebook的参数文件。运行下面命令行，则应该会在Home/username/.jupyter路径下生成一个名为jupyter_notebook_config.py的文件。 1jupyter notebook --generate-config 配置密码。运行下面的命令行，会让你填写密码和确认密码，并生成一段类似于&#39;sha1:0e422dfccef2:84cfbcbb3ef95872fb8e23be3999c123f862d856&#39;的字符串（记下它，备用）。 1jupyter notebook password 配置SSH。用openssl生成自签名证书（365天有效），运行下面命令行后（需要输入一些信息，直接回车键默认值即可），会在当前目录下产生两个文件mykey.key和mycert.pem。 1openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout mykey.key -out mycert.pem 修改配置信息文件。通过文本编辑器，如vim，打开步骤3生成的参数文件jupyter_notebook_config.py。在文件末尾添加下面这段信息： 123456789101112131415# 将步骤5生产的两个文件的绝对路径替换到下面两句话中。c.NotebookApp.certfile &#x3D; u&#39;&#x2F;absolute&#x2F;path&#x2F;to&#x2F;your&#x2F;certificate&#x2F;mycert.pem&#39;c.NotebookApp.keyfile &#x3D; u&#39;&#x2F;absolute&#x2F;path&#x2F;to&#x2F;your&#x2F;certificate&#x2F;mykey.key&#39;# 下面这句话可以不用改。c.NotebookApp.ip &#x3D; &#39;*&#39;# 步骤4生成的一段字符串（前面要求记下备用的），替换到下面单引号内。c.NotebookApp.password &#x3D; u&#39;sha1:bcd259ccf...&#39;# 下面这句话可以不用改。c.NotebookApp.open_browser &#x3D; False# 端口，选择一个空闲的就行，推荐8889或9999等。c.NotebookApp.port &#x3D; 9999 最后，在服务器上打开Jupyter notebook程序： 1Jupyter notebook 在本地计算机上，打开浏览器，地址栏输入: 1234https：&#x2F;&#x2F;服务器的地址:端口&#x2F;如：https:&#x2F;&#x2F;123.123.121.21:8889 浏览器可能会提示有风险，选择“高级”或忽略风险，继续访问即可。之后，会提示输入密码，即步骤1设置的密码。","tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://liangbilin.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"Python","slug":"Python","permalink":"https://liangbilin.github.io/tags/Python/"}]},{"title":"Window系统下安装PyMOL","date":"2019-07-31T16:00:00.000Z","path":"2019/08/01/Billy--Window系统下安装PyMOL/","text":"相关说明PyMOL 是一个开放源码,由使用者赞助的分子三维结构显示软件。由 Warren Lyford DeLano 编写,并且由 Delano Scientific LLC 商业化。 PyMOL 适用于创作高品质的小分子或是生物大分子(特别是蛋白质)的三维结构图像,在所有正式发表的科学文献中蛋白质结构图像中,约四分之一是使用PyMOL来制作。 软件以 Py+MOL 命名:“Py” 表示它是由计算机编程语言Python所衍生出来的;“MOL” 表示它是用于显示分子(molecule)结构的软件。 直接在PyMOL官方网站下载的PyMOL需要购买licence才可使用。免费版本需要自行从源码进行编译。 第一步:安装anaconda(或 minianaconda) 为了节约磁盘,我们选择安装 minianaconda。进入minianaconda官网 ,选择windows 64bit python3版本进行下载。 安装 miniconda:安装过程中建议勾选”将miniconda路径设置到环境变量中”。 第二步:下载安装PyMOL这里有个相关的帖子 从 这个网站 下载pymol-2.3.0-cp37-cp37m-win_amd64.whl文件(PyMOL的源码文件)。需要说明的是,cp37指的是python3.7。如果anaconda对应的python版本是3.8,则下载cp38。 打开pymol-2.3.0-cp37-cp37m-win_amd64.whl文件保存的目录。Shift + 鼠标右键在当前目录下打开Powershell。 于Powershell下运行下面命令,安装pmw:1pip install pmw 于Powershell下运行下面命令,编译安装PyMOL:1pip install pymol-2.3.0-cp37-cp37m-win_amd64.whl 在 miniconda安装目录/script/ 下有一个pymol.exe文件,即PyMOL程序,可以为它创建一个桌面快捷键。 例如 C:\\Users\\liang\\Miniconda3\\Scripts\\pymol.exe PyMOL 使用教程 https://en.wikipedia.org/wiki/PyMOL http://pymol.chenzhaoqiang.com/intro/startManual.html","tags":[{"name":"计算机辅助药物设计","slug":"计算机辅助药物设计","permalink":"https://liangbilin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%8D%AF%E7%89%A9%E8%AE%BE%E8%AE%A1/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"利用AutoDOCK进行分子对接","date":"2019-07-24T16:00:00.000Z","path":"2019/07/25/Billy--利用AutoDOCK进行分子对接/","text":"分子对接(Moleculer-docking)理论分子对接就是两个或多个分子之间通过几何匹配和能量匹配相互识别找到最佳匹配模式的过程。分子对接在酶学研究和药物设计中具有重要的应用意义。 分子对接计算是在受体活性位点区域通过空间结构互补和能量最小化原则来搜寻配体与受体是否能产生相互作用以及它们之间的最佳结合模式。其思想起源于Fisher的锁钥模型(即一把钥匙开一把锁),主要强调的是空间形状的匹配。但配体和受体的识别要比这个模型更加复杂。首先,配体和受体在对接过程中会由于相互适应而产生构象的变化。其次,分子对接还要求能量匹配,对接过程中结合自由能的变化决定了两个分子是否能够结合以及结合的强度。 1958年D.E.Koshland提出分子识别过程中的诱导契合概念,受体分子活性中心的结构原本并非与底物完全吻合,但其是柔软和可塑的。当配体与受体相遇时,可诱导受体构象发生相应的变化,从而便于他们的结合进而引起相应的反应。 分子对接方法根据不同的简化程度分为三类:刚性对接、半柔性对接和柔性对接。刚性对接指在对接过程中,受体和配体的构象不发生变化,适合研究比较大的体系如蛋白-蛋白之间以及蛋白-核酸之间,计算简单,主要考虑对象之间的契合程度。半柔性对接常用于小分子和大分子的对接,在对接过程中,小分子的构象可以在一定范围内变化,但大分子是刚性的。这样既可以在一定程度上考察柔性的影响,又能保持较高的计算效率。在药物设计和虚拟筛选过程中一般采用半柔性的分子对接方法。柔性对接方法一般用于精确研究分子之间的识别情况,由于允许对接体系的构象变化,可以提高对接准确性但耗时较长。 分子对接的目的是找到底物分子和受体分子最佳结合位置及其结合强度,最终可以获得配体和受体的结合构象,但这样的构象可以有很多,一般认为自由能最小的构象存在的概率最高。搜寻最佳构象就要用到构象搜索方法,常用的有系统搜索法和非系统搜索法。系统搜索法通过改变每个扭转角评估所有可能的结合构象,进而选取能量最低的。这一方法计算量非常大。因此通常使用非系统搜索法来寻找能量较低构象,常用方法有:分子动力学方法、随机搜索、遗传算法、距离几何算法等。随机搜索又包括完全随机算法、蒙特卡罗法和模拟退火法等。 分子对接软件包——AutoDockAutoDock软件简介AutoDOCK是一款由Scripps研究所的Olson实验室开发与维护的开源的分子模拟软件,最主要应用于蛋白与小分子配体的分子对接。其用户图形化界面(GUI)工具为AutoDOCK Tools(ADT)。AutoDock的新一代产品为AutoDock Vina。 AutoDock Vina使用拉马克遗传算法提高效率。软件把遗传算法和局部搜索结合在一起,遗传算法用于全局搜索,而局部搜索用于能量优化。为了加快计算速度,AutoDock Vina采用格点(grid)计算。首先在受体活性氨基酸附近划定一个长方体区域作为搜索空间,扫描不同类型的原子计算格点能量,在搜索空间内,调整配体的构象、位置和方向,进而评分、排序获得能量最低的构象作为输出结果。 对范德华相互作用的计算:每个格点上保存的范德华能量的值的数目与要对接的配体上的原子类型数目相同。如果一个配体中含有C、H、O三种原子类型,那么每个葛店需要用单个探针原子与来计算其与受体之间的范德华相互作用值。当配体与受体进行分子对接时,配体中某个原子和受体之间的相互作用能通过周围8个格点上的这种原子类型为探针的格点值用内插法得到。 静电相互作用的计算采用静电势格点。当配体与受体对接时,某个原子和受体之间的静电相互作用能通过周围格点上静电势以及原子上的部分电荷计算得到。 准备docking需要的受体(蛋白)和配体(化合物)Docking算法需要每个原子带有电荷并且需要标记原子的属性。这些信息通常未包含在PDB文件中。我们需要在对蛋白和小分子的PDB文件预处理,生成同时包含以上信息和PDB文件中原子坐标信息的PDBQT格式文件。进一步地对于“柔性配体docking”,我们还需要定义配体的柔性部分和刚性部分。所有这些都可以通过软件AutoDock Tools (adt)来完成。 准备受体蛋白 PDB文件(1hsg.pdb)中包含了蛋白、配体和水分子;首先提取出蛋白的坐标,即以关键字ATOM和TER开头的行存储到文件1hsg_prot.pdb。 在Linux下,使用命令 egrep “^(ATOM|TER)” 1hsg.pdb &gt; 1hsg_prot.pdb 启动AutoDockTools 选择支持GUI的客户端,如MobaXterm,连接服务器。进入AutoDockTools安装目录的’bin’子目录,使用命令 ./adt &amp; 依次点选 File–Read Molecule–1hsg_prot.pdb加载蛋白分子。 ADT中按住左键拖动旋转分子结构;点击中键滚动缩放;按住右键移动晶体位置。 更改展示方式 依次点选 Color–By Atom Type–All Geometries–OK。 加氢:晶体结构中通常缺少氢原子的坐标(因为氢原子电子少,且质子核对电子吸引能力弱,因此很难定位,具体见 http://www.uh.edu/~chembi/ChemSocRev_Jones_critical.pdf )。但是在docking过程中,氢原子尤其是极性氢原子对计算静电作用是必须的。因此我们需要给蛋白加上氢原子,之后氢原子会以白色短线形式出现。 依次点选 Edit–Hydrogen–Add–Polar only–OK(只加极性H) 存储对蛋白的每个原子所做的修改和原子类型判断。 依次点选 Grid–Macromolecule–Choose–1HSG_protein–Slect Molecule (ADT会弹出一个信息框包含程序所做的处理,比如合并非极性氢原子,计算原子局部电荷和判断原子类型,并提示保存Save–1hsg_prot.pdbqt) 在受体蛋白定义配体结合的3D搜索空间。如果我们事先不知道结合位点,理论上可以定义一个长方体盒子包含整个蛋白或者随便一个特定区域 (下文PDB文件解析中会提到PDB文件中有时会包含活性位点信息)。 依次点选 Grid – Grid box ,将会在蛋白上画出一个长方体,并且有一个弹出框。在弹出框中,拖拽刻度线查看长方体的变化,完成设置。在这个例子中,我们知道结合位点,就选取以其为中心的一个小空间。设置Spacing (angstrom)为1埃 (这实际是一个换算系数, 相当于步长; 默认为0.375,是C-C单键长度的1/4,最大为1。spacing值与(各个维度上的点的数目+1)的乘积就是长方体Grid box的大小)。在我们调整的过程中,可以看到随着这个数值的变大,立方体也被放大了。另外我们设置x,y,z center为16,25,4,number of points in (x,y,z)-dimension为30,30,30(最大为126,必须为偶数,AutoDock会自动再每一维再加一个点)。记下我们设置的这些点,下面会用到。在刻度转盘处点击右键会弹出一个窗口,输入数字回车即可设置GRID的中心坐标和大小。较大的number of points in (xyz)-dimension和较小的Spacing会增加搜索的精度,同时需要花费更多的计算时间。 设置受体的柔性残基: 在ADT中依次点选 Flexible Residues–Input–Choose Macromolecule–1hsg_prot; select–select from string–Residue: ARG8–Add–Dismiss, 8号ARG氨基酸残基就被选中了。再依次点选Flexible Residues–Choose Torsions in Currently Selected Residues将选择的残基标记为柔性残基并设置可扭转的数量。在分子显示窗口中分别点击两个残基上CA和CB原子之间的建,使之变为非扭转的(紫色显示)[Shift + 鼠标左键],这样两个残基中的32个键中有6个是可扭转的。这里设置配体的柔性残基或者使CA-CB的键为刚性都是可选操作。放在教程中只是用来展示怎么操作的,无其它指导意义。Flexible Residues–Output–Save Flexible PDBQT保存柔性残基文件。 Flexible Residues–Output–Save Rigid PDBQT保存柔性残基文件。 关掉grid和删除protein Grid Options–File–Close w/out saving; Edit–Delete–Delete Molecule–1hsg_prot–Continue 准备配体与蛋白结构类似,配体的结构也缺少氢原子,我们需要添加氢原子并且定义哪些键是可以旋转的以用于柔性docking。 从PDB结构中提取配体的原子位置。indinavir的配体残基名字为MK1,以HETATM开头的行表示非核心多聚体的成分 (heteroatoms)(具体见PDB文件格式解释)。 Linux系统下,运行 grep “^HETATM.*MK1” 1hsg.pdb &gt; indinavir.pdb 将结构读入ADT: 依次点选 File–Read Molecule–indinavir.pdb依次点选 Color–By Atom Type–All Geometreies–OK 给配体加上氢原子: Edit–Hydrogen–Add–Polar only–OK 在ADT中定义此化合物为配体,以便ADT为其计算局部电荷(partial charges)和设置可旋转配体键。 依次点选 Ligand–input–Choose–indinavir–Select Molecule for AutoDock4这时会有一个弹出框显示ADT所做的操作,包括合并非极性氢(只在添加了的情况下)、计算电荷电量和设置旋转键。然后点选 Ligand–Output–Save as PDBQT 存储结果。 查看ADT检测出的旋转键: 依次点选 Ligand–Torsion Tree–Choose Torsions,可以看到Number of rotatable bonds=14/32。 准备docking配置文件docking配置文件包含了输入的受体(蛋白)、配体(化合物)和搜索参数的信息,为一个文本文件,名字任意,可以为conf.txt,内容如下: receptor = 1hsg_prot.pdbqtligand = indinavir.pdbqtnum_modes = 50out = dockingResult.pdbqtlog = docking.logcenter_x = 16center_y = 25center_z = 4size_x = 30size_y = 30size_z = 30seed = 2009 receptor和ligand为输入文件的名字,与conf.txt在同一目录下; out为输出文件的名字;log为输出日志文件的名字。centerhe和size定义搜索空间的位置和大小。num_modes设置最多显示的结合模型,鉴于只输出符合能量值要求的结果,最后输出的结合模型数量可能少于这一数值。seed设置随机数生成的种子,可以为任意整数。如果想重现之前的分析结果就需要使用相同的seed。 Docking 小分子化合物indinavir到HIV-1蛋白酶 使用AutoDock Vina执行docking预测 在Linux终端执行 path_to_vina/vina –config conf.txt 输出结果包含两个文件,构象文件dockingResult.pdbqt和日志文件docking.log. dockingResult.pdbqt: 包含所有docking的模式,通常第一个为结合最好的构象,但如果前几个能量值相差不大时也有例外。docking.log: 日志文件,包含结合能量值(第一列,越低越稳定,默认由低到高排序,所以第一个为最好的构象)、每个构象与第一个构象的距离、每个构象与第一个构象的差别。 用Pymol可视化结果打开PyMOL,依次点选File–Open文件类型选择All Files-选取结果dockingResult.pdbqt文件、原始蛋白和配体的pdb文件、原教程的pdbqt文件。 用Pymol展示配体和受体相互作用的原子和氢键为了简化展示过程,我们设计了一个pml脚本 (脚本内有很详细的解释),只需要修改脚本里面受体和配体的名字,然后在PyMOL的命令行界面输入PyMOL&gt; run display.pml即可获得展示结果。当然这个脚本也可以使用程序generatePmlForHbond.py生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158 ###############################################################All one needs to do is replacing: ##### * Protein structure file: E:\\docking\\1hsg_prot.pdb ##### * Protein name: 1hsg ##### * Docking result file: E:\\docking\\indinavir.pdbqt ##### * Docking result name (normally ligand name): indinavir## ############################################################# The following 4 lines: # 1. load protein structure and rename it # 2. add hydrogen (&#96;h_add&#96; uses a primitive algorithm to add hydrogens onto a molecule.) # 3. hide protein display # 4. show cartoon display for proteinload E:\\yunpan\\docking\\1hsg_prot.pdb, 1hsgh_add 1hsghide everything, 1hsgshow cartoon, 1hsgcmd.spectrum(&quot;count&quot;, selection&#x3D;&quot;1hsg&quot;, byres&#x3D;1)# The following 6 lines: # 1. load ligand structure and rename it # 2. add hydrogen # 3. hide ligand display # 4. show ligand in sticks mode # 5. Set width of stick to 0.15 # 6. Set atom color: C-white;N-blue;O-redload E:\\yunpan\\docking\\indinavir.pdbqt, indinavirh_add indinavirhide everything, indinavirshow sticks, indinavirset stick_radius, 0.15util.cbaw indinavir# The following 1 line: # 1. Select metal ionsselect metals, symbol mg+ca+fe+zn# The following 2 lines: # 1. Set hydrogen donator # 2. Set hydrogen accrptor # &#96;select&#96; creates a named selection from an atom selection. # &#96;select name, (selection)&#96;select h_donator, (elem n,o and (neighbor hydro))select h_acceptor, (elem o or (elem n and not (neighbor hydro)))# The following 4 lines: # 1. Create link between ligand_h_acceptor and prot_h_donator within given distance 3.2 # 2. Create link between ligand_h_donator and prot_h_acceptor within given distance 3.2 # Set filter 3.6 for ideal geometry and filter 3.2 for minimally acceptable geometry # 3. Set red color for ligand_h_acceptor and prot_h_donator # 4. Set blue color for ligand_h_donator and prot_h_acceptor # &#96;distance&#96; creates a new distance object between two selections. It will display all distances within the cutoff. Distance is also used to make hydrogen bonds like &#96;distance hbonds, all, all, 3.2, mode&#x3D;2&#96;. # distance [ name [, selection1 [, selection2 [, cutoff [, mode ]]]]]distance LaccPdon, (indinavir and h_acceptor), (1hsg and h_donator), 3.2distance LdonPacc, (indinavir and h_donator), (1hsg and h_acceptor), 3.2color red, LaccPdoncolor blue, LdonPacc#distance Fe_C20, (fep and name C20), (heme and name fe))# The following 6 lines: # 1. Select non-hydro atoms of ligands # 2. Select protein atoms within 5A of selected atoms in last step # 3. Label alpha-c(ca) of selected residues with residue name and residue position # 4. Set label color back # 5. Set background white # 6. Hidden hydrogenesselect sele, indinavir &amp; not hydroselect sele, byres (sele expand 5) &amp; 1hsgone_letter &#x3D;&#123;&#39;VAL&#39;:&#39;V&#39;, &#39;ILE&#39;:&#39;I&#39;, &#39;LEU&#39;:&#39;L&#39;, &#39;GLU&#39;:&#39;E&#39;, &#39;GLN&#39;:&#39;Q&#39;, \\&#39;ASP&#39;:&#39;D&#39;, &#39;ASN&#39;:&#39;N&#39;, &#39;HIS&#39;:&#39;H&#39;, &#39;TRP&#39;:&#39;W&#39;, &#39;PHE&#39;:&#39;F&#39;, &#39;TYR&#39;:&#39;Y&#39;, \\&#39;ARG&#39;:&#39;R&#39;, &#39;LYS&#39;:&#39;K&#39;, &#39;SER&#39;:&#39;S&#39;, &#39;THR&#39;:&#39;T&#39;, &#39;MET&#39;:&#39;M&#39;, &#39;ALA&#39;:&#39;A&#39;, \\&#39;GLY&#39;:&#39;G&#39;, &#39;PRO&#39;:&#39;P&#39;, &#39;CYS&#39;:&#39;C&#39;&#125;label name ca &amp; sele, &quot;%s-%s&quot; % (one_letter[resn],resi)bg whiteset label_color, blackhide (hydro)# The follwing 5 lines # 1. Comment out this line # 2. Create an object &#96;surrounding_res&#96; to represent selected protein atoms # &#96;create&#96;: creates a new molecule object from a selection. It can also be used to create states in an existing object. # &#96;create name, (selection)&#96; # 3. Display created surface # 4. Set color for surrounding_res # 5. Set transparency for surrounding_res # Transparency is used to adjust the transparency of Surfaces and Slices. # &#96;set transparency, F, selection&#96;#show surface, 1hsgcreate surrounding_res, seleshow surface, surrounding_rescolor grey80, surrounding_resset transparency, 0.5, surrounding_res此外还可以使用如下脚本(list_hbonds.py)输出相互作用的原子及其位置。# Copyright (c) 2010 Robert L. Campbellfrom pymol import cmddef list_hb(selection,selection2&#x3D;None,cutoff&#x3D;3.2,angle&#x3D;55,mode&#x3D;1,hb_list_name&#x3D;&#39;hbonds&#39;): &quot;&quot;&quot; USAGE list_hb selection, [selection2 (default&#x3D;None)], [cutoff (default&#x3D;3.2)], [angle (default&#x3D;55)], [mode (default&#x3D;1)], [hb_list_name (default&#x3D;&#39;hbonds&#39;)] The script automatically adds a requirement that atoms in the selection (and selection2 if used) must be either of the elements N or O. If mode is set to 0 instead of the default value 1, then no angle cutoff is used, otherwise the angle cutoff is used and defaults to 55 degrees. e.g. To get a list of all H-bonds within chain A of an object list_hb 1abc &amp; c. a &amp;! r. hoh, cutoff&#x3D;3.2, hb_list_name&#x3D;abc-hbonds To get a list of H-bonds between chain B and everything else: list_hb 1tl9 &amp; c. b, 1tl9 &amp;! c. b &quot;&quot;&quot; cutoff&#x3D;float(cutoff) angle&#x3D;float(angle) mode&#x3D;float(mode) # ensure only N and O atoms are in the selection selection &#x3D; selection + &quot; &amp; e. n+o&quot; if not selection2: hb &#x3D; cmd.find_pairs(selection,selection,mode&#x3D;mode,cutoff&#x3D;cutoff,angle&#x3D;angle) else: selection2 &#x3D; selection2 + &quot; &amp; e. n+o&quot; hb &#x3D; cmd.find_pairs(selection,selection2,mode&#x3D;mode,cutoff&#x3D;cutoff,angle&#x3D;angle) # sort the list for easier reading hb.sort(lambda x,y:(cmp(x[0][1],y[0][1]))) for pairs in hb: cmd.iterate(&quot;%s and index %s&quot; % (pairs[0][0],pairs[0][1]), &#39;print &quot;%1s&#x2F;%3s&#96;%s&#x2F;%-4s &quot; % (chain,resn,resi,name),&#39;) cmd.iterate(&quot;%s and index %s&quot; % (pairs[1][0],pairs[1][1]), &#39;print &quot;%1s&#x2F;%3s&#96;%s&#x2F;%-4s &quot; % (chain,resn,resi,name),&#39;) print &quot;%.2f&quot; % cmd.distance(hb_list_name,&quot;%s and index %s&quot; % (pairs[0][0],pairs[0][1]),&quot;%s and index %s&quot; % (pairs[1][0],pairs[1][1]))#cmd.extend(&quot;list_hb&quot;,list_hb)#if __name__ &#x3D;&#x3D; &quot;__main__&quot;:cmd.load(&quot;E:&#x2F;yunpan&#x2F;docking&#x2F;1hsg_prot.pdb&quot;, &quot;1hsg&quot;)cmd.h_add(&quot;(1hsg)&quot;)cmd.load(&quot;E:&#x2F;yunpan&#x2F;docking&#x2F;indinavir.pdbqt&quot;,&quot;indinavir&quot;)cmd.h_add(&quot;(indinavir)&quot;)h_donator &#x3D; &quot;elem n,o &amp; (neighbor hydro)&quot;h_acceptor &#x3D; &quot;elem o | (elem n &amp; !(neighbor hydro))&quot;lacc &#x3D; &quot;indinavir &amp; (elem o | (elem n &amp; !(neighbor hydro)))&quot;ldon &#x3D; &quot;indinavir &amp; (elem n,o &amp; (neighbor hydro))&quot;pacc &#x3D; &quot;1hsg &amp; (elem o | (elem n &amp; !(neighbor hydro)))&quot;pdon &#x3D; &quot;1hsg &amp; (elem n,o &amp; (neighbor hydro))&quot;list_hb(ldon, pacc, hb_list_name&#x3D;&quot;l2p_hbonds&quot;)list_hb(lacc, pdon, hb_list_name&#x3D;&quot;p2l_hbonds&quot;) 输出结果如下:PyMOL&gt;run E:/docking/list_hbonds.pyB/MK1’902/N4 B/GLY’27/O 3.03B/MK1’902/O4 B/GLY’27/O 3.16B/MK1’902/O2 A/ASP’25/OD1 2.77B/MK1’902/O2 B/ASP’25/OD1 2.63 看上去比显示的氢键少了三个,这是因为我们在第二个函数中使用了H-键角度限制,如果在调用时给定参数list_hb(mode=0)则会获得一致结果。H-bond结果展示。第一张图为运行display.pml后的结果,蓝色虚线为氢键;第二张图为运行list_hbonds.py后的结果, 黄色虚线为氢键(覆盖了之前的蓝色)。可以通过点选LaccPdon, LdonPacc, l2p_hbonds显示不同的氢键。 展示疏水表面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# color_h# ------- # PyMOL command to color protein molecules according to the Eisenberg hydrophobicity scale ## Source: http:&#x2F;&#x2F;us.expasy.org&#x2F;tools&#x2F;pscale&#x2F;Hphob.Eisenberg.html# Amino acid scale: Normalized consensus hydrophobicity scale# Author(s): Eisenberg D., Schwarz E., Komarony M., Wall R.# Reference: J. Mol. Biol. 179:125-142 (1984)## Amino acid scale values:## Ala: 0.620# Arg: -2.530# Asn: -0.780# Asp: -0.900# Cys: 0.290# Gln: -0.850# Glu: -0.740# Gly: 0.480# His: -0.400# Ile: 1.380# Leu: 1.060# Lys: -1.500# Met: 0.640# Phe: 1.190# Pro: 0.120# Ser: -0.180# Thr: -0.050# Trp: 0.810# Tyr: 0.260# Val: 1.080## Usage:# color_h (selection)#from pymol import cmd def color_h(selection&#x3D;&#39;all&#39;): s &#x3D; str(selection) print s cmd.set_color(&#39;color_ile&#39;,[0.996,0.062,0.062]) cmd.set_color(&#39;color_phe&#39;,[0.996,0.109,0.109]) cmd.set_color(&#39;color_val&#39;,[0.992,0.156,0.156]) cmd.set_color(&#39;color_leu&#39;,[0.992,0.207,0.207]) cmd.set_color(&#39;color_trp&#39;,[0.992,0.254,0.254]) cmd.set_color(&#39;color_met&#39;,[0.988,0.301,0.301]) cmd.set_color(&#39;color_ala&#39;,[0.988,0.348,0.348]) cmd.set_color(&#39;color_gly&#39;,[0.984,0.394,0.394]) cmd.set_color(&#39;color_cys&#39;,[0.984,0.445,0.445]) cmd.set_color(&#39;color_tyr&#39;,[0.984,0.492,0.492]) cmd.set_color(&#39;color_pro&#39;,[0.980,0.539,0.539]) cmd.set_color(&#39;color_thr&#39;,[0.980,0.586,0.586]) cmd.set_color(&#39;color_ser&#39;,[0.980,0.637,0.637]) cmd.set_color(&#39;color_his&#39;,[0.977,0.684,0.684]) cmd.set_color(&#39;color_glu&#39;,[0.977,0.730,0.730]) cmd.set_color(&#39;color_asn&#39;,[0.973,0.777,0.777]) cmd.set_color(&#39;color_gln&#39;,[0.973,0.824,0.824]) cmd.set_color(&#39;color_asp&#39;,[0.973,0.875,0.875]) cmd.set_color(&#39;color_lys&#39;,[0.899,0.922,0.922]) cmd.set_color(&#39;color_arg&#39;,[0.899,0.969,0.969]) cmd.color(&quot;color_ile&quot;,&quot;(&quot;+s+&quot; and resn ile)&quot;) cmd.color(&quot;color_phe&quot;,&quot;(&quot;+s+&quot; and resn phe)&quot;) cmd.color(&quot;color_val&quot;,&quot;(&quot;+s+&quot; and resn val)&quot;) cmd.color(&quot;color_leu&quot;,&quot;(&quot;+s+&quot; and resn leu)&quot;) cmd.color(&quot;color_trp&quot;,&quot;(&quot;+s+&quot; and resn trp)&quot;) cmd.color(&quot;color_met&quot;,&quot;(&quot;+s+&quot; and resn met)&quot;) cmd.color(&quot;color_ala&quot;,&quot;(&quot;+s+&quot; and resn ala)&quot;) cmd.color(&quot;color_gly&quot;,&quot;(&quot;+s+&quot; and resn gly)&quot;) cmd.color(&quot;color_cys&quot;,&quot;(&quot;+s+&quot; and resn cys)&quot;) cmd.color(&quot;color_tyr&quot;,&quot;(&quot;+s+&quot; and resn tyr)&quot;) cmd.color(&quot;color_pro&quot;,&quot;(&quot;+s+&quot; and resn pro)&quot;) cmd.color(&quot;color_thr&quot;,&quot;(&quot;+s+&quot; and resn thr)&quot;) cmd.color(&quot;color_ser&quot;,&quot;(&quot;+s+&quot; and resn ser)&quot;) cmd.color(&quot;color_his&quot;,&quot;(&quot;+s+&quot; and resn his)&quot;) cmd.color(&quot;color_glu&quot;,&quot;(&quot;+s+&quot; and resn glu)&quot;) cmd.color(&quot;color_asn&quot;,&quot;(&quot;+s+&quot; and resn asn)&quot;) cmd.color(&quot;color_gln&quot;,&quot;(&quot;+s+&quot; and resn gln)&quot;) cmd.color(&quot;color_asp&quot;,&quot;(&quot;+s+&quot; and resn asp)&quot;) cmd.color(&quot;color_lys&quot;,&quot;(&quot;+s+&quot; and resn lys)&quot;) cmd.color(&quot;color_arg&quot;,&quot;(&quot;+s+&quot; and resn arg)&quot;)cmd.extend(&#39;color_h&#39;,color_h) def color_h2(selection&#x3D;&#39;all&#39;): s &#x3D; str(selection) print s cmd.set_color(&quot;color_ile2&quot;,[0.938,1,0.938]) cmd.set_color(&quot;color_phe2&quot;,[0.891,1,0.891]) cmd.set_color(&quot;color_val2&quot;,[0.844,1,0.844]) cmd.set_color(&quot;color_leu2&quot;,[0.793,1,0.793]) cmd.set_color(&quot;color_trp2&quot;,[0.746,1,0.746]) cmd.set_color(&quot;color_met2&quot;,[0.699,1,0.699]) cmd.set_color(&quot;color_ala2&quot;,[0.652,1,0.652]) cmd.set_color(&quot;color_gly2&quot;,[0.606,1,0.606]) cmd.set_color(&quot;color_cys2&quot;,[0.555,1,0.555]) cmd.set_color(&quot;color_tyr2&quot;,[0.508,1,0.508]) cmd.set_color(&quot;color_pro2&quot;,[0.461,1,0.461]) cmd.set_color(&quot;color_thr2&quot;,[0.414,1,0.414]) cmd.set_color(&quot;color_ser2&quot;,[0.363,1,0.363]) cmd.set_color(&quot;color_his2&quot;,[0.316,1,0.316]) cmd.set_color(&quot;color_glu2&quot;,[0.27,1,0.27]) cmd.set_color(&quot;color_asn2&quot;,[0.223,1,0.223]) cmd.set_color(&quot;color_gln2&quot;,[0.176,1,0.176]) cmd.set_color(&quot;color_asp2&quot;,[0.125,1,0.125]) cmd.set_color(&quot;color_lys2&quot;,[0.078,1,0.078]) cmd.set_color(&quot;color_arg2&quot;,[0.031,1,0.031]) cmd.color(&quot;color_ile2&quot;,&quot;(&quot;+s+&quot; and resn ile)&quot;) cmd.color(&quot;color_phe2&quot;,&quot;(&quot;+s+&quot; and resn phe)&quot;) cmd.color(&quot;color_val2&quot;,&quot;(&quot;+s+&quot; and resn val)&quot;) cmd.color(&quot;color_leu2&quot;,&quot;(&quot;+s+&quot; and resn leu)&quot;) cmd.color(&quot;color_trp2&quot;,&quot;(&quot;+s+&quot; and resn trp)&quot;) cmd.color(&quot;color_met2&quot;,&quot;(&quot;+s+&quot; and resn met)&quot;) cmd.color(&quot;color_ala2&quot;,&quot;(&quot;+s+&quot; and resn ala)&quot;) cmd.color(&quot;color_gly2&quot;,&quot;(&quot;+s+&quot; and resn gly)&quot;) cmd.color(&quot;color_cys2&quot;,&quot;(&quot;+s+&quot; and resn cys)&quot;) cmd.color(&quot;color_tyr2&quot;,&quot;(&quot;+s+&quot; and resn tyr)&quot;) cmd.color(&quot;color_pro2&quot;,&quot;(&quot;+s+&quot; and resn pro)&quot;) cmd.color(&quot;color_thr2&quot;,&quot;(&quot;+s+&quot; and resn thr)&quot;) cmd.color(&quot;color_ser2&quot;,&quot;(&quot;+s+&quot; and resn ser)&quot;) cmd.color(&quot;color_his2&quot;,&quot;(&quot;+s+&quot; and resn his)&quot;) cmd.color(&quot;color_glu2&quot;,&quot;(&quot;+s+&quot; and resn glu)&quot;) cmd.color(&quot;color_asn2&quot;,&quot;(&quot;+s+&quot; and resn asn)&quot;) cmd.color(&quot;color_gln2&quot;,&quot;(&quot;+s+&quot; and resn gln)&quot;) cmd.color(&quot;color_asp2&quot;,&quot;(&quot;+s+&quot; and resn asp)&quot;) cmd.color(&quot;color_lys2&quot;,&quot;(&quot;+s+&quot; and resn lys)&quot;) cmd.color(&quot;color_arg2&quot;,&quot;(&quot;+s+&quot; and resn arg)&quot;)cmd.extend(&#39;color_h2&#39;,color_h2) 将上面的脚本存储为color_h.py,在PyMOL界面运行File–Run–color_h.py,在命令行输入 PyMOl color_h –Show surface","tags":[{"name":"计算机辅助药物设计","slug":"计算机辅助药物设计","permalink":"https://liangbilin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%8D%AF%E7%89%A9%E8%AE%BE%E8%AE%A1/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"利用Openbabel预处理小分子数据","date":"2019-07-16T16:00:00.000Z","path":"2019/07/17/Billy--利用Openbabel预处理小分子/","text":"数据库中下载或来源于药物公司的小分子数据往往是2D结构的sdf格式数据。但我们所使用的虚拟筛选却对输入数据有一定的格式要求,如DOCK6要求为mol2格式、AutoDOCK为pdbqt格式。因此,我们需要对2D格式构建出3D结构,并且转换为所需数据格式。开源软件Openbabel可以完成该步骤。 Openbabel的详细功能介绍可以看此网站 （一） Linux系统下安装Openbabel这里介绍的是在Linux系统下安装的简要步骤,详细步骤以及window平台安装可以参考官方教程 从 Openbabel 可以选择相应版本进行下载。这里选择的是目前最新版本2.4.1。 下载完成后,将文件openbabel-2.4.1.tar.gz上传至服务器,解压之后会生成一个openbabel-2.4.1文件: 1tar xzvf openbabel-2.4.1.tar.gz 创建安装文件目录: 12mkdir Openbabelcd Openbabel 预编译openbabel: 1cmake ../openbabel-2.4.1 -DCMAKE_INSTALL_PREFIX=~/tools -DCMAKE_BUILD_TYPE=DEBUG 编译程序: 1make 如果需要设置程序的线程,可以添加参数 -j,如我们设置线程15: 1make -j15 安装程序,之后会在~/tools/bin/目录下看到 obabel 的可执行命令: 1make install （二） 数据介绍使用到的数据是一个包含了几十万个小分子2D结构数据的sdf格式文件。为了能够用于DOCK6的虚拟筛选,需要对其进行3D格式构建、同时转换为mol2数据格式。本文会在最后提供一个包含21个小分子的测试数据。 （三） 将包含几十万个小分子的sdf文件拆分为每个只包含2000个小分子的sdf文件linux系统每个文件目录下所能拥有的文件数是有限制的,为了后续顺利分析,这里使用python脚本split_sdf.py对数据进行拆分。程序运行结束后,将生成数字序号命名的一系列文件目录,目录下面存在包含2000个小分子信息的sdf文件。 12345678910111213141516171819usage: python split_sdf.py large_multi.sdf 2000import sysimport osn = 0out = 1os.mkdir(str(out))with open(sys.argv[1]) as F: for line in F: with open(str(out) + \"/\" + str(out) + \".sdf\", 'a') as O: O.write(line) if \"$$\" in line: if n &lt;= int(sys.argv[2]): n = n+1 else: out = out + 1 os.mkdir(str(out)) n = 0 （四） 针对上步骤的每个目录,拆分数据为:每个小分子单独保存在一个文件中Openbabel 2.4.1 本身是支持包含多分子的文件进行处理的,但测试发现会报错。为了避免该bug,需要将数据进一步拆分,最终文件目录下数据的存在形式为:每个小分子单独保存在一个文件中。 下面命令运行结束后,会在该目录下生成new1.sdf、new2.sdf、new3.sdf… 1obabel 1.sdf -O new.sdf -m （五） 循环迭代,构建小分子的3D结构1234for i in new*.sdfdoobabel $&#123;i&#125; -omol2 -O multi-3D.mol2 --gen3D --conformer --nconf 20 --weighteddone （六） 参考数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681 Marvin 09031813322D 22 23 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 3.0125 3.2460 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.0125 2.4210 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.2980 2.0085 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7270 2.0085 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7270 1.1835 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.4414 0.7710 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.4414 -0.0540 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.1847 -0.4120 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.7895 0.1492 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.5778 -0.0940 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.7614 -0.8983 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.1566 -1.4595 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.3683 -1.2163 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.8539 -1.8613 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.0289 -1.8613 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5145 -1.2163 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.7262 -1.4595 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 -0.8983 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.3050 -0.0940 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.0934 0.1492 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6981 -0.4120 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 3 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 1 0 0 0 0 7 8 2 0 0 0 0 8 9 1 0 0 0 0 9 10 4 0 0 0 0 10 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 9 14 4 0 0 0 0 14 15 1 0 0 0 0 15 16 1 0 0 0 0 16 17 1 0 0 0 0 17 18 4 0 0 0 0 18 19 4 0 0 0 0 19 20 4 0 0 0 0 20 21 4 0 0 0 0 21 22 4 0 0 0 0 8 22 1 0 0 0 0 17 22 4 0 0 0 0M END&gt; &lt;CdId&gt;64&gt; &lt;Formula&gt;C20H24ClN&gt; &lt;ID&gt;T0678&gt; &lt;Name&gt;Amitriptyline hydrochloride&gt; &lt;CAS&gt;549-18-8&gt; &lt;MolWt&gt;313.86&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Neuroscience&gt; &lt;Target&gt;5-HT Receptor antagonist; Norepinephrine inhibitor; Sigma receptor inhibitor&gt; &lt;Receptor&gt;5-HT; 5-HT2; 5-HT4; Norepinephrine receptor; σ1$$$$ Marvin 09031813322D 15 15 0 0 1 0 999 V2000 -0.7145 2.8875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.7145 3.7125 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.0000 2.4750 0.0000 C 0 0 1 0 0 0 0 0 0 0 0 0 -0.4125 1.7605 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 2.0625 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 -0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -1.2375 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.0000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0000 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 -0.4125 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.4125 3.1895 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.4289 2.4750 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 0 1 3 1 0 0 0 0 3 4 1 1 0 0 0 3 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 8 9 4 0 0 0 0 9 10 1 0 0 0 0 9 11 4 0 0 0 0 11 12 4 0 0 0 0 6 12 4 0 0 0 0 8 13 1 0 0 0 0 3 14 1 1 0 0 0 1 15 1 0 0 0 0M END&gt; &lt;CdId&gt;65&gt; &lt;Formula&gt;C10H13NO4&gt; &lt;ID&gt;T0505&gt; &lt;Name&gt;L-(-)-α-Methyldopa&gt; &lt;CAS&gt;555-30-6&gt; &lt;MolWt&gt;211.21&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Neuroscience&gt; &lt;Target&gt;Dopamine Receptor inhibitor&gt; &lt;Receptor&gt;DOPA decarboxylase$$$$ Marvin 09031813322D 48 47 0 0 1 0 999 V2000 0.3572 1.0313 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.3572 0.2063 0.0000 C 0 0 2 0 0 0 0 0 0 0 0 0 -0.3572 -0.2062 0.0000 C 0 0 1 0 0 0 0 0 0 0 0 0 -0.3572 -1.0312 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -1.0717 0.2063 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.7862 -0.2062 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -1.0717 1.0313 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1.0717 -0.2063 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.7862 0.2062 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1.0717 -1.0313 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 4.0255 -2.8007 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.0255 -1.9757 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 4.7399 -1.5632 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.7399 -0.7382 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.4544 -0.3257 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.4544 0.4993 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.1689 0.9118 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.8833 0.4993 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.5978 0.9118 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 8.3123 0.4993 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.0268 0.9118 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.0268 1.7368 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 9.7412 0.4993 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 10.4557 0.9118 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 11.1702 0.4993 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 11.8846 0.9118 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 11.1702 -0.3257 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.8833 -0.3257 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.1689 -0.7382 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.4971 -8.9882 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.4971 -8.1632 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -2.7827 -7.7507 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.7827 -6.9257 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.0682 -6.5132 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.0682 -5.6882 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.3537 -5.2757 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.6393 -5.6882 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0752 -5.2757 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.7897 -5.6882 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.5041 -5.2757 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.5041 -4.4507 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.2186 -5.6882 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9331 -5.2757 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 3.6476 -5.6882 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.3620 -5.2757 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6476 -6.5132 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.6393 -6.5132 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.3537 -6.9257 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 0 0 0 2 3 1 0 0 0 0 3 4 1 1 0 0 0 3 5 1 0 0 0 0 5 6 2 0 0 0 0 5 7 1 0 0 0 0 2 8 1 0 0 0 0 8 9 2 0 0 0 0 8 10 1 0 0 0 0 11 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 14 15 1 0 0 0 0 15 16 4 0 0 0 0 16 17 4 0 0 0 0 17 18 4 0 0 0 0 18 19 1 0 0 0 0 19 20 1 0 0 0 0 20 21 1 0 0 0 0 21 22 1 0 0 0 0 21 23 1 0 0 0 0 23 24 1 0 0 0 0 24 25 1 0 0 0 0 25 26 1 0 0 0 0 25 27 1 0 0 0 0 18 28 4 0 0 0 0 28 29 4 0 0 0 0 15 29 4 0 0 0 0 30 31 1 0 0 0 0 31 32 1 0 0 0 0 32 33 1 0 0 0 0 33 34 1 0 0 0 0 34 35 4 0 0 0 0 35 36 4 0 0 0 0 36 37 4 0 0 0 0 37 38 1 0 0 0 0 38 39 1 0 0 0 0 39 40 1 0 0 0 0 40 41 1 0 0 0 0 40 42 1 0 0 0 0 42 43 1 0 0 0 0 43 44 1 0 0 0 0 44 45 1 0 0 0 0 44 46 1 0 0 0 0 37 47 4 0 0 0 0 47 48 4 0 0 0 0 34 48 4 0 0 0 0M END&gt; &lt;CdId&gt;66&gt; &lt;Formula&gt;C34H56N2O12&gt; &lt;ID&gt;T0487&gt; &lt;Name&gt;Metoprolol tartrate&gt; &lt;CAS&gt;56392-17-7&gt; &lt;MolWt&gt;684.81&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor antagonist&gt; &lt;Receptor&gt;β-adrenergic receptor$$$$ Marvin 09031813322D 19 18 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 0.6875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 0.2750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 -0.5500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 0.6875 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 4.3827 0.2750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.0972 0.6875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.0972 1.5125 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 5.8116 0.2750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.5261 0.6875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.2406 0.2750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.2406 -0.5500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.9551 -0.9625 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 8.6695 -0.5500 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 9.3840 -0.1375 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 9.0820 -1.2645 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 8.2570 0.1645 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.5261 -0.9625 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.8116 -0.5500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 3 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 1 0 0 0 0 7 8 1 0 0 0 0 7 9 1 0 0 0 0 9 10 4 0 0 0 0 10 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 14 15 2 0 0 0 0 14 16 2 0 0 0 0 14 17 1 0 0 0 0 12 18 4 0 0 0 0 18 19 4 0 0 0 0 9 19 4 0 0 0 0M END&gt; &lt;CdId&gt;67&gt; &lt;Formula&gt;C12H21ClN2O3S&gt; &lt;ID&gt;T0483&gt; &lt;Name&gt;Sotalol hydrochloride&gt; &lt;CAS&gt;959-24-0&gt; &lt;MolWt&gt;308.82&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Membrane transporter&#x2F;Ion channel&gt; &lt;Target&gt;Adrenergic Receptor antagonist; Potassium Channel antagonist&gt; &lt;Receptor&gt;β-adrenergic receptor; Potassium Channel$$$$ Marvin 09031813322D 29 29 0 0 1 0 999 V2000 1.2139 -0.5352 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.4995 -0.9477 0.0000 C 0 0 1 0 0 0 0 0 0 0 0 0 -0.2150 -0.5352 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.9295 -0.9477 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -1.6440 -0.5352 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.3976 -0.8708 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -2.9497 -0.2577 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 -2.5372 0.4568 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -1.7302 0.2853 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.1171 0.8373 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -1.2886 1.6443 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.6755 2.1963 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.1091 1.9414 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.2806 1.1344 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.3325 0.5824 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.4995 -1.7727 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1.9284 -0.9477 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.6429 -0.5352 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.3573 -0.1227 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.0554 -1.2497 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.2304 0.1793 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.9538 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 8.7788 -0.0000 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 7.5413 0.7145 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.7163 0.7145 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.3038 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.7163 -0.7145 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 5.4788 0.0000 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 7.5413 -0.7145 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 4 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 8 9 4 0 0 0 0 5 9 4 0 0 0 0 9 10 1 0 0 0 0 10 11 1 0 0 0 0 11 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 14 15 1 0 0 0 0 10 15 1 0 0 0 0 2 16 1 6 0 0 0 1 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 1 0 0 0 0 18 20 1 0 0 0 0 18 21 1 0 0 0 0 22 23 2 0 0 0 0 22 24 1 0 0 0 0 24 25 2 0 0 0 0 25 26 1 0 0 0 0 26 27 2 0 0 0 0 26 28 1 0 0 0 0 22 29 1 0 0 0 0M END&gt; &lt;CdId&gt;68&gt; &lt;Formula&gt;C17H28N4O7S&gt; &lt;ID&gt;T0475&gt; &lt;Name&gt;Timolol Maleate&gt; &lt;CAS&gt;26921-17-5&gt; &lt;MolWt&gt;432.5&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor antagonist&gt; &lt;Receptor&gt;β1-adrenergic receptor; β2-adrenergic receptor$$$$ Marvin 09031813322D 12 11 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 2.2500 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 1.4250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 1.0125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 1.4250 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 0.1875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 -0.2250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 -1.0500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 -1.4625 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 -2.2875 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 -1.0500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 -0.2250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 4 6 1 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 8 9 4 0 0 0 0 9 10 1 0 0 0 0 9 11 4 0 0 0 0 11 12 4 0 0 0 0 6 12 4 0 0 0 0M END&gt; &lt;CdId&gt;69&gt; &lt;Formula&gt;C8H12ClNO2&gt; &lt;ID&gt;T0469&gt; &lt;Name&gt;Octopamine hydrochloride&gt; &lt;CAS&gt;770-05-8&gt; &lt;MolWt&gt;189.64&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Neuroscience&gt; &lt;Target&gt;Dopamine Receptor antagonist&gt; &lt;Receptor&gt;Dopamine$$$$ Marvin 09031813322D 13 12 0 0 1 0 999 V2000 0.7740 2.1656 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.7740 1.3406 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4885 0.9281 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4885 0.1031 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7740 -0.3094 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0595 0.1031 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.6549 -0.3094 0.0000 C 0 0 1 0 0 0 0 0 0 0 0 0 -1.3694 0.1031 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -0.6549 -1.1344 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.3694 -1.5469 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -1.3694 -2.3719 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0595 0.9281 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7278 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 4 0 0 0 0 3 4 4 0 0 0 0 4 5 4 0 0 0 0 5 6 4 0 0 0 0 6 7 1 0 0 0 0 7 8 1 6 0 0 0 7 9 1 0 0 0 0 9 10 1 0 0 0 0 10 11 1 0 0 0 0 6 12 4 0 0 0 0 2 12 4 0 0 0 0M END&gt; &lt;CdId&gt;70&gt; &lt;Formula&gt;C9H14ClNO2&gt; &lt;ID&gt;T0453&gt; &lt;Name&gt;Phenylephrine hydrochloride&gt; &lt;CAS&gt;61-76-7&gt; &lt;MolWt&gt;203.67&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor agonist&gt; &lt;Receptor&gt;α-adrenergic receptor$$$$ Marvin 09031813322D 30 33 0 0 0 0 999 V2000 -7.1935 -5.1943 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -6.4790 -4.7818 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -6.4790 -3.9568 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -7.1935 -3.5443 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -7.1935 -2.7193 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -6.4790 -2.3068 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.7646 -2.7193 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.7646 -3.5443 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.0501 -3.9568 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -4.3356 -3.5443 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.6211 -3.9568 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.9067 -3.5443 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -2.1922 -3.9568 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.4777 -3.5443 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.4777 -2.7193 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -0.7633 -3.9568 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.0488 -3.5443 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.6657 -3.9568 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.6657 -4.7818 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.3802 -5.1943 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.0946 -4.7818 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.0946 -3.9568 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.3802 -3.5443 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.5517 -2.7373 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.0668 -2.0699 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4023 -1.3162 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.2228 -1.2300 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.7077 -1.8974 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.3722 -2.6511 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.7077 -3.4048 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 1 0 0 0 0 3 4 4 0 0 0 0 4 5 4 0 0 0 0 5 6 4 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 3 8 4 0 0 0 0 8 9 1 0 0 0 0 9 10 1 0 0 0 0 10 11 1 0 0 0 0 11 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 14 15 1 0 0 0 0 14 16 1 0 0 0 0 16 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 4 0 0 0 0 19 20 4 0 0 0 0 20 21 4 0 0 0 0 21 22 4 0 0 0 0 22 23 4 0 0 0 0 18 23 4 0 0 0 0 23 24 4 0 0 0 0 24 25 4 0 0 0 0 25 26 4 0 0 0 0 26 27 4 0 0 0 0 27 28 4 0 0 0 0 28 29 4 0 0 0 0 24 29 4 0 0 0 0 29 30 4 0 0 0 0 22 30 4 0 0 0 0M STY 1 1 DATM SAL 1 1 30M SDT 1 MRV_IMPLICIT_H M SDD 1 0.0000 0.0000 DR ALL 0 0 M SED 1 IMPL_H1M END&gt; &lt;CdId&gt;71&gt; &lt;Formula&gt;C24H26N2O4&gt; &lt;ID&gt;T0447&gt; &lt;Name&gt;Carvedilol&gt; &lt;CAS&gt;72956-09-3&gt; &lt;MolWt&gt;406.47&gt; &lt;Pathways&gt;Angiogenesis; Neuroscience; Cytoskeletal Signaling; Membrane transporter&#x2F;Ion channel; Metabolism; Others; Chromatin&#x2F;Epigenetic; GPCR&#x2F;G Protein; Tyrosine Kinase&#x2F;Adaptors&gt; &lt;Target&gt;Adrenergic Receptor inhibitor; HIF modulator; Integrin inhibitor; NADPH inhibitor; Others inhibitor; Potassium Channel inhibitor; VEGFR inhibitor&gt; &lt;Receptor&gt;Adrenergic Receptor; HIF; E-selectin; NADPH; Vcam; Potassium Channel; VEGFR$$$$ Marvin 09031813322D 17 18 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 4.2595 -0.7927 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5450 -1.2052 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.4588 -2.0257 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.6518 -2.1972 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 -1.4827 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.7913 -0.8696 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 4.2595 0.0323 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5450 0.4448 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5450 1.2698 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2595 1.6823 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.9739 1.2698 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6884 1.6823 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.4029 1.2698 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.4029 0.4448 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6884 0.0323 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.9739 0.4448 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 2 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 1 0 0 0 0 3 7 1 0 0 0 0 2 8 1 0 0 0 0 8 9 4 0 0 0 0 9 10 4 0 0 0 0 10 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 14 15 4 0 0 0 0 15 16 4 0 0 0 0 16 17 4 0 0 0 0 8 17 4 0 0 0 0 12 17 4 0 0 0 0M END&gt; &lt;CdId&gt;72&gt; &lt;Formula&gt;C14H15ClN2&gt; &lt;ID&gt;T0446&gt; &lt;Name&gt;Naphazoline hydrochloride&gt; &lt;CAS&gt;550-99-2&gt; &lt;MolWt&gt;246.74&gt; &lt;Pathways&gt;Neuroscience; GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor&gt; &lt;Receptor&gt;Adrenergic Receptor$$$$ Marvin 09031813322D 21 22 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 0.9075 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 1.3200 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 0.9075 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 0.0825 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 4.9793 -0.3300 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6938 0.0825 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.4083 -0.3300 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.4083 -1.1550 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6938 -1.5675 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.9793 -1.1550 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 -1.5675 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 -1.1550 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 -1.5675 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 -1.1550 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 -0.3300 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 0.0825 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 -0.3300 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 2.1450 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 2.5575 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 2.5575 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 8 9 4 0 0 0 0 9 10 4 0 0 0 0 10 11 4 0 0 0 0 6 11 4 0 0 0 0 11 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 4 0 0 0 0 14 15 4 0 0 0 0 15 16 4 0 0 0 0 16 17 4 0 0 0 0 17 18 4 0 0 0 0 5 18 1 0 0 0 0 13 18 4 0 0 0 0 3 19 1 0 0 0 0 19 20 1 0 0 0 0 19 21 1 0 0 0 0M END&gt; &lt;CdId&gt;73&gt; &lt;Formula&gt;C17H21ClN2S&gt; &lt;ID&gt;T0445L&gt; &lt;Name&gt;Promethazine hydrochloride&gt; &lt;CAS&gt;58-33-3&gt; &lt;MolWt&gt;320.88&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Immunology&#x2F;Inflammation; Neuroscience&gt; &lt;Target&gt;Adrenergic Receptor antagonist; Histamine Receptor antagonist&gt; &lt;Receptor&gt;α-adrenergic receptor; H1 receptor$$$$ Marvin 09031813322D 20 22 0 0 0 0 999 V2000 0.7145 2.0625 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 2.4750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 2.0625 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 1.2375 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.8579 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5724 1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2868 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2868 -0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5724 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8579 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 -0.4125 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0000 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 3.3000 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 4 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 8 9 4 0 0 0 0 9 10 4 0 0 0 0 5 10 4 0 0 0 0 10 11 1 0 0 0 0 11 12 1 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 14 15 4 0 0 0 0 15 16 4 0 0 0 0 16 17 4 0 0 0 0 4 17 1 0 0 0 0 12 17 4 0 0 0 0 2 18 1 0 0 0 0 18 19 1 0 0 0 0 18 20 1 0 0 0 0M END&gt; &lt;CdId&gt;74&gt; &lt;Formula&gt;C17H20N2S&gt; &lt;ID&gt;T0445&gt; &lt;Name&gt;Promethazine&gt; &lt;CAS&gt;60-87-7&gt; &lt;MolWt&gt;284.42&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Neuroscience; Immunology&#x2F;Inflammation&gt; &lt;Target&gt;5-HT Receptor antagonist; AChR antagonist; Adrenergic Receptor antagonist; CaMK inhibitor; Dopamine Receptor antagonist; Histamine Receptor antagonist&gt; &lt;Receptor&gt;5-HT; mAChR; Adrenergic Receptor; CAM; D2; H1 receptor$$$$ Marvin 09031813322D 15 17 0 0 0 0 999 V2000 1.8414 -3.7445 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.0164 -3.7445 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7615 -2.9599 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 -2.4750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.0964 -2.9599 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 -1.6500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8579 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5724 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5724 -1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8579 -1.6500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 -1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 1 0 0 0 0 3 4 2 0 0 0 0 4 5 1 0 0 0 0 1 5 1 0 0 0 0 4 6 1 0 0 0 0 6 7 1 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 1 0 0 0 0 10 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 14 15 4 0 0 0 0 6 15 1 0 0 0 0 10 15 4 0 0 0 0M END&gt; &lt;CdId&gt;75&gt; &lt;Formula&gt;C13H16N2&gt; &lt;ID&gt;T0397&gt; &lt;Name&gt;Tetryzoline&gt; &lt;CAS&gt;84-22-0&gt; &lt;MolWt&gt;200.28&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor agonist&gt; &lt;Receptor&gt;α-adrenergic receptor$$$$ Marvin 09031813322D 21 20 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 5.5759 1.3613 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.5759 0.5363 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.2904 0.1238 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.8615 0.1238 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.8615 -0.7013 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.5759 -1.1138 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 6.2904 -0.7013 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.0049 -1.1138 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.7193 -0.7013 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 8.4338 -1.1138 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.7193 0.1238 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.1470 -1.1138 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.4325 -0.7013 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.7180 -1.1138 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.4325 0.1237 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.7180 0.5362 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.7180 1.3612 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.0036 1.7737 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 3.4325 1.7737 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.1470 0.5363 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 3 5 1 0 0 0 0 5 6 4 0 0 0 0 6 7 1 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 1 0 0 0 0 10 11 1 0 0 0 0 10 12 1 0 0 0 0 6 13 4 0 0 0 0 13 14 4 0 0 0 0 14 15 1 0 0 0 0 14 16 4 0 0 0 0 16 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 2 0 0 0 0 18 20 1 0 0 0 0 16 21 4 0 0 0 0 5 21 4 0 0 0 0M END&gt; &lt;CdId&gt;76&gt; &lt;Formula&gt;C16H26ClNO3&gt; &lt;ID&gt;T0394&gt; &lt;Name&gt;Moxisylyte hydrochloride&gt; &lt;CAS&gt;964-52-3&gt; &lt;MolWt&gt;315.84&gt; &lt;Pathways&gt;Neuroscience; GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor inhibitor&gt; &lt;Receptor&gt;Adrenergic Receptor$$$$ Marvin 09031813322D 20 21 0 0 0 0 999 V2000 -1.2765 0.4040 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.4515 0.4040 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.0390 -0.3105 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -0.4515 -1.0249 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.2765 -1.0249 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.6890 -0.3105 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.1740 -0.9779 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.9586 -0.7230 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -2.9586 0.1020 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.6260 0.5870 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -2.1740 0.3570 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.7860 -0.3105 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.1985 0.4040 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.0235 0.4040 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.4360 1.1185 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.2610 1.1185 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6735 0.4040 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.2610 -0.3105 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.4360 -0.3105 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.9128 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 1 6 1 0 0 0 0 6 7 1 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 2 0 0 0 0 9 11 1 0 0 0 0 6 11 1 0 0 0 0 3 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 14 15 4 0 0 0 0 15 16 4 0 0 0 0 16 17 4 0 0 0 0 17 18 4 0 0 0 0 18 19 4 0 0 0 0 14 19 4 0 0 0 0M END&gt; &lt;CdId&gt;77&gt; &lt;Formula&gt;C15H21ClN2O2&gt; &lt;ID&gt;T0383&gt; &lt;Name&gt;Fenspiride hydrochloride&gt; &lt;CAS&gt;5053-08-7&gt; &lt;MolWt&gt;296.79&gt; &lt;Pathways&gt;Metabolism&gt; &lt;Target&gt;PDE inhibitor&gt; &lt;Receptor&gt;PDE3; PDE4$$$$ Marvin 09031813322D 26 28 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 7.8372 -0.7920 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.1227 -0.3795 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 6.4083 -0.7920 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6938 -0.3795 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.9793 -0.7920 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.9793 -1.6170 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 -2.0295 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 -1.6170 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 -2.0295 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 -1.6170 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 -0.7920 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 -0.3795 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 -0.7920 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 -0.3795 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 0.4455 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 0.8580 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 1.6830 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 2.0955 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 2.9205 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 3.3330 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 2.9205 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 2.0955 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 4.9793 1.6830 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6938 -2.0295 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.4083 -1.6170 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 4 0 0 0 0 5 6 4 0 0 0 0 6 7 4 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 4 0 0 0 0 10 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 9 14 4 0 0 0 0 14 15 1 0 0 0 0 6 15 1 0 0 0 0 15 16 1 0 0 0 0 16 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 1 0 0 0 0 19 20 1 0 0 0 0 20 21 1 0 0 0 0 21 22 1 0 0 0 0 22 23 1 0 0 0 0 18 23 1 0 0 0 0 23 24 1 0 0 0 0 7 25 4 0 0 0 0 25 26 4 0 0 0 0 4 26 4 0 0 0 0M END&gt; &lt;CdId&gt;78&gt; &lt;Formula&gt;C21H27ClN2S2&gt; &lt;ID&gt;T0365&gt; &lt;Name&gt;Thioridazine hydrochloride&gt; &lt;CAS&gt;130-61-0&gt; &lt;MolWt&gt;407.04&gt; &lt;Pathways&gt;Neuroscience; GPCR&#x2F;G Protein; Membrane transporter&#x2F;Ion channel&gt; &lt;Target&gt;5-HT Receptor antagonist; Adrenergic Receptor antagonist; Dopamine Receptor antagonist; Potassium Channel inhibitor&gt; &lt;Receptor&gt;5-HT; Adrenergic Receptor; Dopamine; Potassium Channel$$$$ Marvin 09031813322D 30 34 0 0 0 0 999 V2000 0.0000 -1.6500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7145 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.0000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.7145 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.4289 -0.0000 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -2.1434 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.8579 -0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.8579 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.1434 1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.4289 0.8250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.5724 1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.6586 2.0580 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -4.4656 2.2295 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -4.8781 1.5150 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -4.3260 0.9019 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -4.5810 0.1173 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.3879 -0.0542 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.9400 0.5589 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -6.7469 0.3874 0.0000 F 0 0 0 0 0 0 0 0 0 0 0 0 -5.6850 1.3435 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 0.8250 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 -0.4125 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.8579 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5724 -0.4125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5724 -1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8579 -1.6500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1434 -1.2375 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.4289 -1.6500 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 4 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 1 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 1 0 0 0 0 10 11 1 0 0 0 0 6 11 1 0 0 0 0 9 12 1 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 14 15 4 0 0 0 0 15 16 4 0 0 0 0 12 16 4 0 0 0 0 16 17 4 0 0 0 0 17 18 4 0 0 0 0 18 19 4 0 0 0 0 19 20 1 0 0 0 0 19 21 4 0 0 0 0 15 21 4 0 0 0 0 3 22 4 0 0 0 0 22 23 2 0 0 0 0 22 24 4 0 0 0 0 24 25 1 0 0 0 0 25 26 1 0 0 0 0 26 27 1 0 0 0 0 27 28 1 0 0 0 0 28 29 1 0 0 0 0 24 29 4 0 0 0 0 29 30 4 0 0 0 0 2 30 4 0 0 0 0M END&gt; &lt;CdId&gt;79&gt; &lt;Formula&gt;C23H27FN4O2&gt; &lt;ID&gt;T0351&gt; &lt;Name&gt;Risperidal&gt; &lt;CAS&gt;106266-06-2&gt; &lt;MolWt&gt;410.48&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein; Neuroscience&gt; &lt;Target&gt;5-HT Receptor antagonist; Adrenergic Receptor antagonist; Dopamine Receptor antagonist&gt; &lt;Receptor&gt;5-HT2A; α2C-adrenergic receptor; D2; D2L; D3$$$$ Marvin 09031813322D 25 25 0 0 0 0 999 V2000 1.2206 1.0141 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.2206 0.1891 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.5061 -0.2234 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -0.2084 0.1891 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.9229 -0.2234 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.6373 0.1891 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.3518 -0.2234 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.0663 0.1891 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.7807 -0.2234 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -4.4952 0.1891 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -3.7807 -1.0484 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -3.0663 1.0141 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.3518 1.4266 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.6373 1.0141 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.7807 1.4266 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -0.9229 -1.0484 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1.9350 -0.2234 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.6495 0.1891 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.3640 -0.2234 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.0784 0.1891 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.7929 -0.2234 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.7929 -1.0484 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.0784 -1.4609 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.3640 -1.0484 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.0322 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 4 0 0 0 0 7 8 4 0 0 0 0 8 9 1 0 0 0 0 9 10 2 0 0 0 0 9 11 1 0 0 0 0 8 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 6 14 4 0 0 0 0 12 15 1 0 0 0 0 5 16 1 0 0 0 0 2 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 1 0 0 0 0 19 20 4 0 0 0 0 20 21 4 0 0 0 0 21 22 4 0 0 0 0 22 23 4 0 0 0 0 23 24 4 0 0 0 0 19 24 4 0 0 0 0M END&gt; &lt;CdId&gt;80&gt; &lt;Formula&gt;C19H25ClN2O3&gt; &lt;ID&gt;T0348&gt; &lt;Name&gt;Labetalol hydrochloride&gt; &lt;CAS&gt;32780-64-6&gt; &lt;MolWt&gt;364.87&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor antagonist&gt; &lt;Receptor&gt;α1-adrenergic receptor$$$$ Marvin 09031813322D 36 37 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.8286 -0.8250 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.8286 0.0000 0.0000 P 0 0 0 0 0 0 0 0 0 0 0 0 2.8286 0.8250 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 3.6536 -0.0000 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.0036 0.0000 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -3.4322 -6.1875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.4322 -5.3625 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -4.1467 -4.9500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -4.8612 -5.3625 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.5756 -4.9500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.5756 -4.1250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -4.8612 -3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -4.1467 -4.1250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.4322 -3.7125 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -2.7178 -4.1250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -2.0033 -3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.2888 -4.1250 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -0.5744 -3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.1401 -4.1250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.1401 -4.9500 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 0.8546 -3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.5691 -4.1250 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 2.2835 -3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.2835 -2.8875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9980 -2.4750 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7125 -2.8875 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7125 -3.7125 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.3256 -4.2645 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 3.9900 -5.0182 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.3256 -5.7719 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.8406 -6.4393 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.0202 -6.3531 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.6846 -5.5994 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.1695 -4.9320 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9980 -4.1250 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 3 5 1 0 0 0 0 3 6 2 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 4 0 0 0 0 10 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 9 14 4 0 0 0 0 14 15 1 0 0 0 0 15 16 1 0 0 0 0 16 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 1 0 0 0 0 19 20 1 0 0 0 0 20 21 1 0 0 0 0 20 22 1 0 0 0 0 22 23 1 0 0 0 0 23 24 1 0 0 0 0 24 25 4 0 0 0 0 25 26 4 0 0 0 0 26 27 4 0 0 0 0 27 28 4 0 0 0 0 28 29 4 0 0 0 0 29 30 4 0 0 0 0 30 31 4 0 0 0 0 31 32 4 0 0 0 0 32 33 4 0 0 0 0 33 34 4 0 0 0 0 34 35 4 0 0 0 0 30 35 4 0 0 0 0 35 36 4 0 0 0 0 24 36 4 0 0 0 0 28 36 4 0 0 0 0M STY 1 1 DATM SAL 1 1 29M SDT 1 MRV_IMPLICIT_H M SDD 1 0.0000 0.0000 DR ALL 0 0 M SED 1 IMPL_H1M END&gt; &lt;CdId&gt;81&gt; &lt;Formula&gt;C24H31N2O9P&gt; &lt;ID&gt;T0342&gt; &lt;Name&gt;Carvedilol phosphate&gt; &lt;CAS&gt;610309-89-2&gt; &lt;MolWt&gt;522.49&gt; &lt;Pathways&gt;Neuroscience; Angiogenesis; Cytoskeletal Signaling; Membrane transporter&#x2F;Ion channel; Metabolism; Others; GPCR&#x2F;G Protein; Tyrosine Kinase&#x2F;Adaptors&gt; &lt;Target&gt;Adrenergic Receptor antagonist; Gap Junction Protein inhibitor; Integrin inhibitor; NADPH inhibitor; Others inhibitor; Potassium Channel inhibitor; VEGFR inhibitor&gt; &lt;Receptor&gt;Adrenergic Receptor; Gap Junction Protein; E-selectin; NADPH dehydrogenase; Natriuretic peptides B; VCAM1; Potassium Channel; VEGFR$$$$ Marvin 09031813322D 23 23 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 5.6938 -0.9187 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.6938 -0.0937 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.9793 0.3188 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.2648 -0.0937 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 0.3187 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 -0.0938 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 0.3187 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.1214 1.1438 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.8359 1.5563 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.5504 1.1437 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 6.4083 0.3188 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 7.1227 -0.0937 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.1227 -0.9187 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.8372 0.3188 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.8372 1.1438 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 8.5517 -0.0937 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.2661 0.3188 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.9806 -0.0937 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.9806 -0.9187 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 10.6951 -1.3312 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 9.2661 -1.3312 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 8.5517 -0.9187 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 2 0 0 0 0 7 8 1 0 0 0 0 8 9 2 0 0 0 0 9 10 1 0 0 0 0 10 11 2 0 0 0 0 6 11 1 0 0 0 0 3 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 13 15 1 0 0 0 0 15 16 1 0 0 0 0 15 17 1 0 0 0 0 17 18 2 0 0 0 0 18 19 1 0 0 0 0 19 20 2 0 0 0 0 20 21 1 0 0 0 0 20 22 1 0 0 0 0 22 23 2 0 0 0 0 17 23 1 0 0 0 0M END&gt; &lt;CdId&gt;82&gt; &lt;Formula&gt;C18H24ClNO3&gt; &lt;ID&gt;T0324&gt; &lt;Name&gt;Isoxsuprine hydrochloride&gt; &lt;CAS&gt;579-56-6&gt; &lt;MolWt&gt;337.84&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor agonist&gt; &lt;Receptor&gt;β-adrenergic receptor$$$$ Marvin 09031813322D 23 23 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 2.2393 0.9235 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.9538 1.3360 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 0.9235 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.3827 1.3360 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.0972 0.9235 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.8116 1.3360 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 6.5261 0.9235 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.0972 0.0985 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.8116 -0.3140 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.8116 -1.1390 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 6.5261 0.0985 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.2406 -0.3140 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 7.9551 0.0985 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 8.6695 -0.3140 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 9.4232 0.0216 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.9752 -0.5915 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 9.5627 -1.3060 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 8.7558 -1.1345 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.3827 -0.3140 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.3827 -1.1390 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 -1.5515 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.6682 0.0985 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 1 0 0 0 0 4 5 4 0 0 0 0 5 6 4 0 0 0 0 6 7 1 0 0 0 0 7 8 1 0 0 0 0 6 9 4 0 0 0 0 9 10 1 0 0 0 0 10 11 2 0 0 0 0 10 12 1 0 0 0 0 12 13 1 0 0 0 0 13 14 1 0 0 0 0 14 15 1 0 0 0 0 15 16 1 0 0 0 0 16 17 1 0 0 0 0 17 18 1 0 0 0 0 18 19 1 0 0 0 0 15 19 1 0 0 0 0 9 20 4 0 0 0 0 20 21 1 0 0 0 0 21 22 1 0 0 0 0 20 23 4 0 0 0 0 4 23 4 0 0 0 0M END&gt; &lt;CdId&gt;83&gt; &lt;Formula&gt;C17H26ClNO4&gt; &lt;ID&gt;T0317&gt; &lt;Name&gt;Buflomedil hydrochloride&gt; &lt;CAS&gt;35543-24-9&gt; &lt;MolWt&gt;343.85&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor antagonist&gt; &lt;Receptor&gt;α-adrenergic receptor$$$$ Marvin 09031813322D 17 18 0 0 0 0 999 V2000 0.0000 0.0000 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 5.4165 0.0839 0.0000 Cl 0 0 0 0 0 0 0 0 0 0 0 0 4.7021 0.4964 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.9876 0.0839 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.9876 -0.7411 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 4.7021 -1.1536 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.4557 -0.8181 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 6.0078 -1.4312 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 5.5953 -2.1456 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.7883 -1.9741 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 3.2731 0.4964 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2.4885 0.2414 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 2.0036 0.9089 0.0000 S 0 0 0 0 0 0 0 0 0 0 0 0 2.4885 1.5763 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 3.2731 1.3214 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.9876 1.7339 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 4.7021 1.3214 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 2 3 1 0 0 0 0 3 4 4 0 0 0 0 4 5 1 0 0 0 0 5 6 1 0 0 0 0 6 7 2 0 0 0 0 7 8 1 0 0 0 0 8 9 1 0 0 0 0 9 10 1 0 0 0 0 6 10 1 0 0 0 0 4 11 4 0 0 0 0 11 12 4 0 0 0 0 12 13 4 0 0 0 0 13 14 4 0 0 0 0 14 15 4 0 0 0 0 11 15 4 0 0 0 0 15 16 4 0 0 0 0 16 17 4 0 0 0 0 3 17 4 0 0 0 0M END&gt; &lt;CdId&gt;84&gt; &lt;Formula&gt;C9H9Cl2N5S&gt; &lt;ID&gt;T0290&gt; &lt;Name&gt;Tizanidine hydrochloride&gt; &lt;CAS&gt;64461-82-1&gt; &lt;MolWt&gt;290.17&gt; &lt;Pathways&gt;GPCR&#x2F;G Protein&gt; &lt;Target&gt;Adrenergic Receptor agonist&gt; &lt;Receptor&gt;α2-adrenergic receptor$$$$","tags":[{"name":"计算机辅助药物设计","slug":"计算机辅助药物设计","permalink":"https://liangbilin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%8D%AF%E7%89%A9%E8%AE%BE%E8%AE%A1/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"蛋白结构同源建模","date":"2019-07-09T16:00:00.000Z","path":"2019/07/10/Billy--蛋白结构同源建模/","text":"无论在药物设计还是分子模拟等研究中,蛋白质结构信息都是必需的。结构生物学领域能够利用扫描电镜,核磁共振以及X衍射等手段获取大多数蛋白质的结构。然而,一方面,蛋白质结构的解析工作需要专业平台来完成,可是很多实验团队并不具备这样的平台;另一方面,在如疾病暴发等应急情景下需要迅速获取蛋白结构信息。此时,我们可以选择蛋白质结构预测的方式开展工作。 蛋白质结构预测分为同源建模和从头预测两大类。同源建模是指利用具有相似氨基酸序列且蛋白结构信息已知的蛋白质作为模板,来进行蛋白结构模型的构建。从头预测则是指不依赖于模板,仅从氨基酸序列信息进行蛋白结构模型的构建。实践表明,同源建模预测的准确度高于从头预测。可实现同源建模的工具有Swiss Model、INSIGHTii、modeller、spdbvierwer等等。 图片转载地址 利用 Swiss Model 构建蛋白结构模型Swiss Model 是巴塞尔大学推出的一款在线同源建模服务器,其使用非常简单方便,只需要将序列粘入,即可自动化处理结果,下面是其简单的使用方法: 第一步,打开 Swiss Model的官方网页,可以看到如下界面。点击 Start Modelling 开始进行模型构建。 Swiss Model 的官方网页界面 第二步,在新的界面输入氨基酸序列或上传包含序列的文件。然后,点击 Search For Templates 开始检索模板信息。 这里提供一个氨基酸测试序列: 1MDEMATTQISKDELDELKEAFAKVDLNSNGFICDYELHELFKEANMPLPGYKVREIIQKLMLDGDRNKDGKISFDEFVYIFQEVKSSDIAKTFRKAINRKEGICALGGTSELSSEGTQHSYSEEEKYAFVNWINKALENDPDCRHVIPMNPNTDDLFKAVGDGIVLCKMINLSVPDTIDERAINKKKLTPFIIQENLNLALNSASAIGCHVVNIGAEDLRAGKPHLVLGLLWQIIKIGLFADIELSRNEALAALLRDGETLEELMKLSPEELLLRWANFHLENSGWQKINNFSADIKDSKAYFHLLNQIAPKGQKEGEPRIDINMSGFNETDDLKRAESMLQQADKLGCRQFVTPADVVSGNPKLNLAFVANLFNKYPALTKPENQDIDWTLLEGETREERTFRNWMNSLGVNPHVNHLYADLQDALVILQLYERIKVPVDWSKVNKPPYPKLGANMKKLENCNYAVELGKHPAKFSLVGIGGQDLNDGNQTLTLALVWQLMRRYTLNVLEDLGDGQKANDDIIVNWVNRTLSEAGKSTSIQSFKDKTISSSLAVVDLIDAIQPGCINYDLVKSGNLTEDDKHNNAKYAVSMARRIGARVYALPEDLVEVKPKMVMTVFACLMGRGMKRV 模板检索结果如下: 第三步,勾选模板之后,点击 Build Models 进行建模。 作为测试,只选第一个模板进行模型构建。真正实践过程中,可适当多选择几个模板进行构建,然后进行评估,以确定最佳模型。 建模结果如下: 最后,可以将模型下载下来,使用 PyMOL 软件进行可视化。","tags":[{"name":"计算机辅助药物设计","slug":"计算机辅助药物设计","permalink":"https://liangbilin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%8D%AF%E7%89%A9%E8%AE%BE%E8%AE%A1/"},{"name":"Demo","slug":"Demo","permalink":"https://liangbilin.github.io/tags/Demo/"}]},{"title":"Markdown 语法","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/Billy--Markdown学习笔记/","text":"简介Markdown是一种轻量级标记语言,排版语法简洁,让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档,可与HTML混编,可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写,Markdown被大量使用,如Github、Wikipedia等网站,如各大博客平台:WordPress、Drupal、简书等。 初级教程标题1234# 一级标题## 二级标题### 三级标题#### 四级标题 粗体12**粗体**__粗体__ 斜体12*粗体*_粗体_ 段落和换行第一种方法:直接敲两个回车键第二种方法:在写完一段之后,敲两个空格,然后再敲回车键第三种方法:在写完一段之后,使用HTML的标记符 &lt;br /&gt;作为换行符 分隔线在一行中用三个及以上的星号(*)、减号(-)、等于号(=)或者下划线(_)来创建分隔线。 1234***---&#x3D;&#x3D;&#x3D;___ 引言12&gt; 这是一个引言&gt; 这是另一个引言 ( 标记 &gt; 放到引用的语句最前面,需要注意的是每段的开头都要加 &gt; 标记) 这是一个引言这是另一个引言 无序列表无序列表可以在每行开头用星号、加号、减号来表示,也可以三者混合一起,推荐使用相同的字符,避免混乱。 123* 一朵百合花* 两朵百合花* 三朵百合花 一朵百合花 两朵百合花 三朵百合花 有序列表有序列表用数字接着一个英文句点来表示,数字可无序。 1231. 一朵百合花2. 两朵百合花3. 三朵百合花 一朵百合花 两朵百合花 三朵百合花 插入代码 插入单行代码,用一对反引号把代码引起来。1&#96;这是一行代码&#96; 插入多行代码,用一对 三个连续的反引号把多行代码引起来。123456\\&#96;\\&#96;\\&#96;第一行代码(实际使用,去掉 \\ )第二行代码...第N行代码\\&#96;\\&#96;\\&#96; 网址链接网址链接有两种方式:行内式、参考式。对于行内式,链接文字是用 [方括号] 来标记,网址是用 (括号) 来标记,Title是用 “双引号” 来标记的。1[Google](https:&#x2F;&#x2F;www.google.com.hk&#x2F;webhp &quot;Google&quot;) 这是一个行内式的网址链接:Google 对于参考式,一般写法是:(注意下面的代码中间需要空一行) 12345这是一个参考式的网址链接:[Google][1]这是另一个参考式网址链接:[Baidu][2][1]: https:&#x2F;&#x2F;www.google.com.hk&#x2F;webhp[2]: https:&#x2F;&#x2F;www.Baidu.com 这是一个参考式的网址链接:Google这是另一个参考式网址链接:Baidu 在参考式中,还有一种隐式写法是: 12345这是一个参考式的网址链接:[Google][]这是另一个参考式网址链接:[Baidu][][Google]: https:&#x2F;&#x2F;www.google.com.hk&#x2F;webhp[Baidu]: https:&#x2F;&#x2F;www.Baidu.com 这是一个参考式的网址链接:Google这是另一个参考式网址链接:Baidu 图片链接图片链接与上面的网址链接类似,同样有两种形式:行内式和参考式,只不过图片链接在前面加上一个感叹号 ! 图片可以放在本地,也可以上传到一些云端,比如 SM.MS ,将图片上传到这个网站上,它会提供一个相应的链接。 行内式 1![谷歌](https:&#x2F;&#x2F;www.google.com&#x2F;images&#x2F;branding&#x2F;googlelogo&#x2F;2x&#x2F;googlelogo_color_120x44dp.png &quot;Google&quot;) 参考式 123![谷歌][1][1]: https:&#x2F;&#x2F;www.google.com&#x2F;images&#x2F;branding&#x2F;googlelogo&#x2F;2x&#x2F;googlelogo_color_120x44dp.png &quot;Google&quot; Markdown文件开头格式在Markdown的开头部分需要对文档做一些定义,比如文档的Tags、Categories、title、date等,如下: 123456---title: &#39;Markdown 学习笔记&#39;date: 2019-06-02 17:12:44tags: [Markdown, 编程, 教程]categories: 标记语言---","tags":[{"name":"标记语言","slug":"标记语言","permalink":"https://liangbilin.github.io/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"}]}]